// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium -D Default -D PartialEq -A -d kubeadmcontrolplanes.controlplane.cluster.x-k8s.io
// kopium version: 0.21.2

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use schemars::JsonSchema;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
    pub use k8s_openapi::apimachinery::pkg::util::intstr::IntOrString;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
    pub use k8s_openapi::api::core::v1::ObjectReference;
}
use self::prelude::*;

/// spec is the desired state of KubeadmControlPlane.
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
#[kube(group = "controlplane.cluster.x-k8s.io", version = "v1beta1", kind = "KubeadmControlPlane", plural = "kubeadmcontrolplanes")]
#[kube(namespaced)]
#[kube(status = "KubeadmControlPlaneStatus")]
#[kube(derive="Default")]
#[kube(derive="PartialEq")]
pub struct KubeadmControlPlaneSpec {
    /// kubeadmConfigSpec is a KubeadmConfigSpec
    /// to use for initializing and joining machines to the control plane.
    #[serde(rename = "kubeadmConfigSpec")]
    pub kubeadm_config_spec: KubeadmControlPlaneKubeadmConfigSpec,
    /// machineNamingStrategy allows changing the naming pattern used when creating Machines.
    /// InfraMachines & KubeadmConfigs will use the same name as the corresponding Machines.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "machineNamingStrategy")]
    pub machine_naming_strategy: Option<KubeadmControlPlaneMachineNamingStrategy>,
    /// machineTemplate contains information about how machines
    /// should be shaped when creating or updating a control plane.
    #[serde(rename = "machineTemplate")]
    pub machine_template: KubeadmControlPlaneMachineTemplate,
    /// remediationStrategy is the RemediationStrategy that controls how control plane machine remediation happens.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "remediationStrategy")]
    pub remediation_strategy: Option<KubeadmControlPlaneRemediationStrategy>,
    /// replicas is the number of desired machines. Defaults to 1. When stacked etcd is used only
    /// odd numbers are permitted, as per [etcd best practice](https://etcd.io/docs/v3.3.12/faq/#why-an-odd-number-of-cluster-members).
    /// This is a pointer to distinguish between explicit zero and not specified.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replicas: Option<i32>,
    /// rolloutAfter is a field to indicate a rollout should be performed
    /// after the specified time even if no changes have been made to the
    /// KubeadmControlPlane.
    /// Example: In the YAML the time can be specified in the RFC3339 format.
    /// To specify the rolloutAfter target as March 9, 2023, at 9 am UTC
    /// use "2023-03-09T09:00:00Z".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rolloutAfter")]
    pub rollout_after: Option<String>,
    /// rolloutBefore is a field to indicate a rollout should be performed
    /// if the specified criteria is met.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rolloutBefore")]
    pub rollout_before: Option<KubeadmControlPlaneRolloutBefore>,
    /// rolloutStrategy is the RolloutStrategy to use to replace control plane machines with
    /// new ones.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rolloutStrategy")]
    pub rollout_strategy: Option<KubeadmControlPlaneRolloutStrategy>,
    /// version defines the desired Kubernetes version.
    /// Please note that if kubeadmConfigSpec.ClusterConfiguration.imageRepository is not set
    /// we don't allow upgrades to versions >= v1.22.0 for which kubeadm uses the old registry (k8s.gcr.io).
    /// Please use a newer patch version with the new registry instead. The default registries of kubeadm are:
    ///   * registry.k8s.io (new registry): >= v1.22.17, >= v1.23.15, >= v1.24.9, >= v1.25.0
    ///   * k8s.gcr.io (old registry): all older versions
    pub version: String,
}

/// kubeadmConfigSpec is a KubeadmConfigSpec
/// to use for initializing and joining machines to the control plane.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct KubeadmControlPlaneKubeadmConfigSpec {
    /// bootCommands specifies extra commands to run very early in the boot process via the cloud-init bootcmd
    /// module. bootcmd will run on every boot, 'cloud-init-per' command can be used to make bootcmd run exactly
    /// once. This is typically run in the cloud-init.service systemd unit. This has no effect in Ignition.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bootCommands")]
    pub boot_commands: Option<Vec<String>>,
    /// clusterConfiguration along with InitConfiguration are the configurations necessary for the init command
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterConfiguration")]
    pub cluster_configuration: Option<KubeadmControlPlaneKubeadmConfigSpecClusterConfiguration>,
    /// diskSetup specifies options for the creation of partition tables and file systems on devices.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "diskSetup")]
    pub disk_setup: Option<KubeadmControlPlaneKubeadmConfigSpecDiskSetup>,
    /// files specifies extra files to be passed to user_data upon creation.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub files: Option<Vec<KubeadmControlPlaneKubeadmConfigSpecFiles>>,
    /// format specifies the output format of the bootstrap data
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub format: Option<KubeadmControlPlaneKubeadmConfigSpecFormat>,
    /// ignition contains Ignition specific configuration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ignition: Option<KubeadmControlPlaneKubeadmConfigSpecIgnition>,
    /// initConfiguration along with ClusterConfiguration are the configurations necessary for the init command
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initConfiguration")]
    pub init_configuration: Option<KubeadmControlPlaneKubeadmConfigSpecInitConfiguration>,
    /// joinConfiguration is the kubeadm configuration for the join command
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "joinConfiguration")]
    pub join_configuration: Option<KubeadmControlPlaneKubeadmConfigSpecJoinConfiguration>,
    /// mounts specifies a list of mount points to be setup.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mounts: Option<Vec<Vec<String>>>,
    /// ntp specifies NTP configuration
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ntp: Option<KubeadmControlPlaneKubeadmConfigSpecNtp>,
    /// postKubeadmCommands specifies extra commands to run after kubeadm runs.
    /// With cloud-init, this is appended to the runcmd module configuration, and is typically executed in
    /// the cloud-final.service systemd unit. In Ignition, this is appended to /etc/kubeadm.sh.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "postKubeadmCommands")]
    pub post_kubeadm_commands: Option<Vec<String>>,
    /// preKubeadmCommands specifies extra commands to run before kubeadm runs.
    /// With cloud-init, this is prepended to the runcmd module configuration, and is typically executed in
    /// the cloud-final.service systemd unit. In Ignition, this is prepended to /etc/kubeadm.sh.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preKubeadmCommands")]
    pub pre_kubeadm_commands: Option<Vec<String>>,
    /// useExperimentalRetryJoin replaces a basic kubeadm command with a shell
    /// script with retries for joins.
    ///
    /// This is meant to be an experimental temporary workaround on some environments
    /// where joins fail due to timing (and other issues). The long term goal is to add retries to
    /// kubeadm proper and use that functionality.
    ///
    /// This will add about 40KB to userdata
    ///
    /// For more information, refer to https://github.com/kubernetes-sigs/cluster-api/pull/2763#discussion_r397306055.
    ///
    /// Deprecated: This experimental fix is no longer needed and this field will be removed in a future release.
    /// When removing also remove from staticcheck exclude-rules for SA1019 in golangci.yml
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "useExperimentalRetryJoin")]
    pub use_experimental_retry_join: Option<bool>,
    /// users specifies extra users to add
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub users: Option<Vec<KubeadmControlPlaneKubeadmConfigSpecUsers>>,
    /// verbosity is the number for the kubeadm log level verbosity.
    /// It overrides the `--v` flag in kubeadm commands.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub verbosity: Option<i32>,
}

/// clusterConfiguration along with InitConfiguration are the configurations necessary for the init command
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct KubeadmControlPlaneKubeadmConfigSpecClusterConfiguration {
    /// apiServer contains extra settings for the API server control plane component
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiServer")]
    pub api_server: Option<KubeadmControlPlaneKubeadmConfigSpecClusterConfigurationApiServer>,
    /// APIVersion defines the versioned schema of this representation of an object.
    /// Servers should convert recognized schemas to the latest internal value, and
    /// may reject unrecognized values.
    /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    /// certificatesDir specifies where to store or look for all required certificates.
    /// NB: if not provided, this will default to `/etc/kubernetes/pki`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certificatesDir")]
    pub certificates_dir: Option<String>,
    /// clusterName is the cluster name
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterName")]
    pub cluster_name: Option<String>,
    /// controlPlaneEndpoint sets a stable IP address or DNS name for the control plane; it
    /// can be a valid IP address or a RFC-1123 DNS subdomain, both with optional TCP port.
    /// In case the ControlPlaneEndpoint is not specified, the AdvertiseAddress + BindPort
    /// are used; in case the ControlPlaneEndpoint is specified but without a TCP port,
    /// the BindPort is used.
    /// Possible usages are:
    /// e.g. In a cluster with more than one control plane instances, this field should be
    /// assigned the address of the external load balancer in front of the
    /// control plane instances.
    /// e.g.  in environments with enforced node recycling, the ControlPlaneEndpoint
    /// could be used for assigning a stable DNS to the control plane.
    /// NB: This value defaults to the first value in the Cluster object status.apiEndpoints array.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "controlPlaneEndpoint")]
    pub control_plane_endpoint: Option<String>,
    /// controllerManager contains extra settings for the controller manager control plane component
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "controllerManager")]
    pub controller_manager: Option<KubeadmControlPlaneKubeadmConfigSpecClusterConfigurationControllerManager>,
    /// dns defines the options for the DNS add-on installed in the cluster.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dns: Option<KubeadmControlPlaneKubeadmConfigSpecClusterConfigurationDns>,
    /// etcd holds configuration for etcd.
    /// NB: This value defaults to a Local (stacked) etcd
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub etcd: Option<KubeadmControlPlaneKubeadmConfigSpecClusterConfigurationEtcd>,
    /// featureGates enabled by the user.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "featureGates")]
    pub feature_gates: Option<BTreeMap<String, bool>>,
    /// imageRepository sets the container registry to pull images from.
    /// * If not set, the default registry of kubeadm will be used, i.e.
    ///   * registry.k8s.io (new registry): >= v1.22.17, >= v1.23.15, >= v1.24.9, >= v1.25.0
    ///   * k8s.gcr.io (old registry): all older versions
    ///   Please note that when imageRepository is not set we don't allow upgrades to
    ///   versions >= v1.22.0 which use the old registry (k8s.gcr.io). Please use
    ///   a newer patch version with the new registry instead (i.e. >= v1.22.17,
    ///   >= v1.23.15, >= v1.24.9, >= v1.25.0).
    /// * If the version is a CI build (kubernetes version starts with `ci/` or `ci-cross/`)
    ///  `gcr.io/k8s-staging-ci-images` will be used as a default for control plane components
    ///   and for kube-proxy, while `registry.k8s.io` will be used for all the other images.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imageRepository")]
    pub image_repository: Option<String>,
    /// Kind is a string value representing the REST resource this object represents.
    /// Servers may infer this from the endpoint the client submits requests to.
    /// Cannot be updated.
    /// In CamelCase.
    /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kind: Option<String>,
    /// kubernetesVersion is the target version of the control plane.
    /// NB: This value defaults to the Machine object spec.version
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kubernetesVersion")]
    pub kubernetes_version: Option<String>,
    /// networking holds configuration for the networking topology of the cluster.
    /// NB: This value defaults to the Cluster object spec.clusterNetwork.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub networking: Option<KubeadmControlPlaneKubeadmConfigSpecClusterConfigurationNetworking>,
    /// scheduler contains extra settings for the scheduler control plane component
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scheduler: Option<KubeadmControlPlaneKubeadmConfigSpecClusterConfigurationScheduler>,
}

/// apiServer contains extra settings for the API server control plane component
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct KubeadmControlPlaneKubeadmConfigSpecClusterConfigurationApiServer {
    /// certSANs sets extra Subject Alternative Names for the API Server signing cert.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certSANs")]
    pub cert_sa_ns: Option<Vec<String>>,
    /// extraArgs is an extra set of flags to pass to the control plane component.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "extraArgs")]
    pub extra_args: Option<BTreeMap<String, String>>,
    /// extraEnvs is an extra set of environment variables to pass to the control plane component.
    /// Environment variables passed using ExtraEnvs will override any existing environment variables, or *_proxy environment variables that kubeadm adds by default.
    /// This option takes effect only on Kubernetes >=1.31.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "extraEnvs")]
    pub extra_envs: Option<Vec<KubeadmControlPlaneKubeadmConfigSpecClusterConfigurationApiServerExtraEnvs>>,
    /// extraVolumes is an extra set of host volumes, mounted to the control plane component.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "extraVolumes")]
    pub extra_volumes: Option<Vec<KubeadmControlPlaneKubeadmConfigSpecClusterConfigurationApiServerExtraVolumes>>,
    /// timeoutForControlPlane controls the timeout that we use for API server to appear
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeoutForControlPlane")]
    pub timeout_for_control_plane: Option<String>,
}

/// EnvVar represents an environment variable present in a Container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct KubeadmControlPlaneKubeadmConfigSpecClusterConfigurationApiServerExtraEnvs {
    /// Name of the environment variable. Must be a C_IDENTIFIER.
    pub name: String,
    /// Variable references $(VAR_NAME) are expanded
    /// using the previously defined environment variables in the container and
    /// any service environment variables. If a variable cannot be resolved,
    /// the reference in the input string will be unchanged. Double $$ are reduced
    /// to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
    /// "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
    /// Escaped references will never be expanded, regardless of whether the variable
    /// exists or not.
    /// Defaults to "".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
    /// Source for the environment variable's value. Cannot be used if value is not empty.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<KubeadmControlPlaneKubeadmConfigSpecClusterConfigurationApiServerExtraEnvsValueFrom>,
}

/// Source for the environment variable's value. Cannot be used if value is not empty.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct KubeadmControlPlaneKubeadmConfigSpecClusterConfigurationApiServerExtraEnvsValueFrom {
    /// Selects a key of a ConfigMap.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMapKeyRef")]
    pub config_map_key_ref: Option<KubeadmControlPlaneKubeadmConfigSpecClusterConfigurationApiServerExtraEnvsValueFromConfigMapKeyRef>,
    /// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
    /// spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldRef")]
    pub field_ref: Option<KubeadmControlPlaneKubeadmConfigSpecClusterConfigurationApiServerExtraEnvsValueFromFieldRef>,
    /// Selects a resource of the container: only resources limits and requests
    /// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceFieldRef")]
    pub resource_field_ref: Option<KubeadmControlPlaneKubeadmConfigSpecClusterConfigurationApiServerExtraEnvsValueFromResourceFieldRef>,
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<KubeadmControlPlaneKubeadmConfigSpecClusterConfigurationApiServerExtraEnvsValueFromSecretKeyRef>,
}

/// Selects a key of a ConfigMap.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct KubeadmControlPlaneKubeadmConfigSpecClusterConfigurationApiServerExtraEnvsValueFromConfigMapKeyRef {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
/// spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct KubeadmControlPlaneKubeadmConfigSpecClusterConfigurationApiServerExtraEnvsValueFromFieldRef {
    /// Version of the schema the FieldPath is written in terms of, defaults to "v1".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    /// Path of the field to select in the specified API version.
    #[serde(rename = "fieldPath")]
    pub field_path: String,
}

/// Selects a resource of the container: only resources limits and requests
/// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct KubeadmControlPlaneKubeadmConfigSpecClusterConfigurationApiServerExtraEnvsValueFromResourceFieldRef {
    /// Container name: required for volumes, optional for env vars
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerName")]
    pub container_name: Option<String>,
    /// Specifies the output format of the exposed resources, defaults to "1"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub divisor: Option<IntOrString>,
    /// Required: resource to select
    pub resource: String,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct KubeadmControlPlaneKubeadmConfigSpecClusterConfigurationApiServerExtraEnvsValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// HostPathMount contains elements describing volumes that are mounted from the
/// host.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct KubeadmControlPlaneKubeadmConfigSpecClusterConfigurationApiServerExtraVolumes {
    /// hostPath is the path in the host that will be mounted inside
    /// the pod.
    #[serde(rename = "hostPath")]
    pub host_path: String,
    /// mountPath is the path inside the pod where hostPath will be mounted.
    #[serde(rename = "mountPath")]
    pub mount_path: String,
    /// name of the volume inside the pod template.
    pub name: String,
    /// pathType is the type of the HostPath.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathType")]
    pub path_type: Option<String>,
    /// readOnly controls write access to the volume
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
}

/// controllerManager contains extra settings for the controller manager control plane component
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct KubeadmControlPlaneKubeadmConfigSpecClusterConfigurationControllerManager {
    /// extraArgs is an extra set of flags to pass to the control plane component.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "extraArgs")]
    pub extra_args: Option<BTreeMap<String, String>>,
    /// extraEnvs is an extra set of environment variables to pass to the control plane component.
    /// Environment variables passed using ExtraEnvs will override any existing environment variables, or *_proxy environment variables that kubeadm adds by default.
    /// This option takes effect only on Kubernetes >=1.31.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "extraEnvs")]
    pub extra_envs: Option<Vec<KubeadmControlPlaneKubeadmConfigSpecClusterConfigurationControllerManagerExtraEnvs>>,
    /// extraVolumes is an extra set of host volumes, mounted to the control plane component.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "extraVolumes")]
    pub extra_volumes: Option<Vec<KubeadmControlPlaneKubeadmConfigSpecClusterConfigurationControllerManagerExtraVolumes>>,
}

/// EnvVar represents an environment variable present in a Container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct KubeadmControlPlaneKubeadmConfigSpecClusterConfigurationControllerManagerExtraEnvs {
    /// Name of the environment variable. Must be a C_IDENTIFIER.
    pub name: String,
    /// Variable references $(VAR_NAME) are expanded
    /// using the previously defined environment variables in the container and
    /// any service environment variables. If a variable cannot be resolved,
    /// the reference in the input string will be unchanged. Double $$ are reduced
    /// to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
    /// "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
    /// Escaped references will never be expanded, regardless of whether the variable
    /// exists or not.
    /// Defaults to "".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
    /// Source for the environment variable's value. Cannot be used if value is not empty.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<KubeadmControlPlaneKubeadmConfigSpecClusterConfigurationControllerManagerExtraEnvsValueFrom>,
}

/// Source for the environment variable's value. Cannot be used if value is not empty.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct KubeadmControlPlaneKubeadmConfigSpecClusterConfigurationControllerManagerExtraEnvsValueFrom {
    /// Selects a key of a ConfigMap.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMapKeyRef")]
    pub config_map_key_ref: Option<KubeadmControlPlaneKubeadmConfigSpecClusterConfigurationControllerManagerExtraEnvsValueFromConfigMapKeyRef>,
    /// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
    /// spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldRef")]
    pub field_ref: Option<KubeadmControlPlaneKubeadmConfigSpecClusterConfigurationControllerManagerExtraEnvsValueFromFieldRef>,
    /// Selects a resource of the container: only resources limits and requests
    /// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceFieldRef")]
    pub resource_field_ref: Option<KubeadmControlPlaneKubeadmConfigSpecClusterConfigurationControllerManagerExtraEnvsValueFromResourceFieldRef>,
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<KubeadmControlPlaneKubeadmConfigSpecClusterConfigurationControllerManagerExtraEnvsValueFromSecretKeyRef>,
}

/// Selects a key of a ConfigMap.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct KubeadmControlPlaneKubeadmConfigSpecClusterConfigurationControllerManagerExtraEnvsValueFromConfigMapKeyRef {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
/// spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct KubeadmControlPlaneKubeadmConfigSpecClusterConfigurationControllerManagerExtraEnvsValueFromFieldRef {
    /// Version of the schema the FieldPath is written in terms of, defaults to "v1".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    /// Path of the field to select in the specified API version.
    #[serde(rename = "fieldPath")]
    pub field_path: String,
}

/// Selects a resource of the container: only resources limits and requests
/// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct KubeadmControlPlaneKubeadmConfigSpecClusterConfigurationControllerManagerExtraEnvsValueFromResourceFieldRef {
    /// Container name: required for volumes, optional for env vars
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerName")]
    pub container_name: Option<String>,
    /// Specifies the output format of the exposed resources, defaults to "1"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub divisor: Option<IntOrString>,
    /// Required: resource to select
    pub resource: String,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct KubeadmControlPlaneKubeadmConfigSpecClusterConfigurationControllerManagerExtraEnvsValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// HostPathMount contains elements describing volumes that are mounted from the
/// host.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct KubeadmControlPlaneKubeadmConfigSpecClusterConfigurationControllerManagerExtraVolumes {
    /// hostPath is the path in the host that will be mounted inside
    /// the pod.
    #[serde(rename = "hostPath")]
    pub host_path: String,
    /// mountPath is the path inside the pod where hostPath will be mounted.
    #[serde(rename = "mountPath")]
    pub mount_path: String,
    /// name of the volume inside the pod template.
    pub name: String,
    /// pathType is the type of the HostPath.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathType")]
    pub path_type: Option<String>,
    /// readOnly controls write access to the volume
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
}

/// dns defines the options for the DNS add-on installed in the cluster.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct KubeadmControlPlaneKubeadmConfigSpecClusterConfigurationDns {
    /// imageRepository sets the container registry to pull images from.
    /// if not set, the ImageRepository defined in ClusterConfiguration will be used instead.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imageRepository")]
    pub image_repository: Option<String>,
    /// imageTag allows to specify a tag for the image.
    /// In case this value is set, kubeadm does not change automatically the version of the above components during upgrades.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imageTag")]
    pub image_tag: Option<String>,
}

/// etcd holds configuration for etcd.
/// NB: This value defaults to a Local (stacked) etcd
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct KubeadmControlPlaneKubeadmConfigSpecClusterConfigurationEtcd {
    /// external describes how to connect to an external etcd cluster
    /// Local and External are mutually exclusive
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub external: Option<KubeadmControlPlaneKubeadmConfigSpecClusterConfigurationEtcdExternal>,
    /// local provides configuration knobs for configuring the local etcd instance
    /// Local and External are mutually exclusive
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub local: Option<KubeadmControlPlaneKubeadmConfigSpecClusterConfigurationEtcdLocal>,
}

/// external describes how to connect to an external etcd cluster
/// Local and External are mutually exclusive
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct KubeadmControlPlaneKubeadmConfigSpecClusterConfigurationEtcdExternal {
    /// caFile is an SSL Certificate Authority file used to secure etcd communication.
    /// Required if using a TLS connection.
    #[serde(rename = "caFile")]
    pub ca_file: String,
    /// certFile is an SSL certification file used to secure etcd communication.
    /// Required if using a TLS connection.
    #[serde(rename = "certFile")]
    pub cert_file: String,
    /// endpoints of etcd members. Required for ExternalEtcd.
    pub endpoints: Vec<String>,
    /// keyFile is an SSL key file used to secure etcd communication.
    /// Required if using a TLS connection.
    #[serde(rename = "keyFile")]
    pub key_file: String,
}

/// local provides configuration knobs for configuring the local etcd instance
/// Local and External are mutually exclusive
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct KubeadmControlPlaneKubeadmConfigSpecClusterConfigurationEtcdLocal {
    /// dataDir is the directory etcd will place its data.
    /// Defaults to "/var/lib/etcd".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataDir")]
    pub data_dir: Option<String>,
    /// extraArgs are extra arguments provided to the etcd binary
    /// when run inside a static pod.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "extraArgs")]
    pub extra_args: Option<BTreeMap<String, String>>,
    /// extraEnvs is an extra set of environment variables to pass to the control plane component.
    /// Environment variables passed using ExtraEnvs will override any existing environment variables, or *_proxy environment variables that kubeadm adds by default.
    /// This option takes effect only on Kubernetes >=1.31.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "extraEnvs")]
    pub extra_envs: Option<Vec<KubeadmControlPlaneKubeadmConfigSpecClusterConfigurationEtcdLocalExtraEnvs>>,
    /// imageRepository sets the container registry to pull images from.
    /// if not set, the ImageRepository defined in ClusterConfiguration will be used instead.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imageRepository")]
    pub image_repository: Option<String>,
    /// imageTag allows to specify a tag for the image.
    /// In case this value is set, kubeadm does not change automatically the version of the above components during upgrades.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imageTag")]
    pub image_tag: Option<String>,
    /// peerCertSANs sets extra Subject Alternative Names for the etcd peer signing cert.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "peerCertSANs")]
    pub peer_cert_sa_ns: Option<Vec<String>>,
    /// serverCertSANs sets extra Subject Alternative Names for the etcd server signing cert.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serverCertSANs")]
    pub server_cert_sa_ns: Option<Vec<String>>,
}

/// EnvVar represents an environment variable present in a Container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct KubeadmControlPlaneKubeadmConfigSpecClusterConfigurationEtcdLocalExtraEnvs {
    /// Name of the environment variable. Must be a C_IDENTIFIER.
    pub name: String,
    /// Variable references $(VAR_NAME) are expanded
    /// using the previously defined environment variables in the container and
    /// any service environment variables. If a variable cannot be resolved,
    /// the reference in the input string will be unchanged. Double $$ are reduced
    /// to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
    /// "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
    /// Escaped references will never be expanded, regardless of whether the variable
    /// exists or not.
    /// Defaults to "".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
    /// Source for the environment variable's value. Cannot be used if value is not empty.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<KubeadmControlPlaneKubeadmConfigSpecClusterConfigurationEtcdLocalExtraEnvsValueFrom>,
}

/// Source for the environment variable's value. Cannot be used if value is not empty.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct KubeadmControlPlaneKubeadmConfigSpecClusterConfigurationEtcdLocalExtraEnvsValueFrom {
    /// Selects a key of a ConfigMap.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMapKeyRef")]
    pub config_map_key_ref: Option<KubeadmControlPlaneKubeadmConfigSpecClusterConfigurationEtcdLocalExtraEnvsValueFromConfigMapKeyRef>,
    /// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
    /// spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldRef")]
    pub field_ref: Option<KubeadmControlPlaneKubeadmConfigSpecClusterConfigurationEtcdLocalExtraEnvsValueFromFieldRef>,
    /// Selects a resource of the container: only resources limits and requests
    /// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceFieldRef")]
    pub resource_field_ref: Option<KubeadmControlPlaneKubeadmConfigSpecClusterConfigurationEtcdLocalExtraEnvsValueFromResourceFieldRef>,
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<KubeadmControlPlaneKubeadmConfigSpecClusterConfigurationEtcdLocalExtraEnvsValueFromSecretKeyRef>,
}

/// Selects a key of a ConfigMap.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct KubeadmControlPlaneKubeadmConfigSpecClusterConfigurationEtcdLocalExtraEnvsValueFromConfigMapKeyRef {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
/// spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct KubeadmControlPlaneKubeadmConfigSpecClusterConfigurationEtcdLocalExtraEnvsValueFromFieldRef {
    /// Version of the schema the FieldPath is written in terms of, defaults to "v1".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    /// Path of the field to select in the specified API version.
    #[serde(rename = "fieldPath")]
    pub field_path: String,
}

/// Selects a resource of the container: only resources limits and requests
/// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct KubeadmControlPlaneKubeadmConfigSpecClusterConfigurationEtcdLocalExtraEnvsValueFromResourceFieldRef {
    /// Container name: required for volumes, optional for env vars
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerName")]
    pub container_name: Option<String>,
    /// Specifies the output format of the exposed resources, defaults to "1"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub divisor: Option<IntOrString>,
    /// Required: resource to select
    pub resource: String,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct KubeadmControlPlaneKubeadmConfigSpecClusterConfigurationEtcdLocalExtraEnvsValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// networking holds configuration for the networking topology of the cluster.
/// NB: This value defaults to the Cluster object spec.clusterNetwork.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct KubeadmControlPlaneKubeadmConfigSpecClusterConfigurationNetworking {
    /// dnsDomain is the dns domain used by k8s services. Defaults to "cluster.local".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dnsDomain")]
    pub dns_domain: Option<String>,
    /// podSubnet is the subnet used by pods.
    /// If unset, the API server will not allocate CIDR ranges for every node.
    /// Defaults to a comma-delimited string of the Cluster object's spec.clusterNetwork.services.cidrBlocks if that is set
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "podSubnet")]
    pub pod_subnet: Option<String>,
    /// serviceSubnet is the subnet used by k8s services.
    /// Defaults to a comma-delimited string of the Cluster object's spec.clusterNetwork.pods.cidrBlocks, or
    /// to "10.96.0.0/12" if that's unset.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceSubnet")]
    pub service_subnet: Option<String>,
}

/// scheduler contains extra settings for the scheduler control plane component
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct KubeadmControlPlaneKubeadmConfigSpecClusterConfigurationScheduler {
    /// extraArgs is an extra set of flags to pass to the control plane component.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "extraArgs")]
    pub extra_args: Option<BTreeMap<String, String>>,
    /// extraEnvs is an extra set of environment variables to pass to the control plane component.
    /// Environment variables passed using ExtraEnvs will override any existing environment variables, or *_proxy environment variables that kubeadm adds by default.
    /// This option takes effect only on Kubernetes >=1.31.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "extraEnvs")]
    pub extra_envs: Option<Vec<KubeadmControlPlaneKubeadmConfigSpecClusterConfigurationSchedulerExtraEnvs>>,
    /// extraVolumes is an extra set of host volumes, mounted to the control plane component.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "extraVolumes")]
    pub extra_volumes: Option<Vec<KubeadmControlPlaneKubeadmConfigSpecClusterConfigurationSchedulerExtraVolumes>>,
}

/// EnvVar represents an environment variable present in a Container.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct KubeadmControlPlaneKubeadmConfigSpecClusterConfigurationSchedulerExtraEnvs {
    /// Name of the environment variable. Must be a C_IDENTIFIER.
    pub name: String,
    /// Variable references $(VAR_NAME) are expanded
    /// using the previously defined environment variables in the container and
    /// any service environment variables. If a variable cannot be resolved,
    /// the reference in the input string will be unchanged. Double $$ are reduced
    /// to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
    /// "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
    /// Escaped references will never be expanded, regardless of whether the variable
    /// exists or not.
    /// Defaults to "".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
    /// Source for the environment variable's value. Cannot be used if value is not empty.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "valueFrom")]
    pub value_from: Option<KubeadmControlPlaneKubeadmConfigSpecClusterConfigurationSchedulerExtraEnvsValueFrom>,
}

/// Source for the environment variable's value. Cannot be used if value is not empty.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct KubeadmControlPlaneKubeadmConfigSpecClusterConfigurationSchedulerExtraEnvsValueFrom {
    /// Selects a key of a ConfigMap.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "configMapKeyRef")]
    pub config_map_key_ref: Option<KubeadmControlPlaneKubeadmConfigSpecClusterConfigurationSchedulerExtraEnvsValueFromConfigMapKeyRef>,
    /// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
    /// spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldRef")]
    pub field_ref: Option<KubeadmControlPlaneKubeadmConfigSpecClusterConfigurationSchedulerExtraEnvsValueFromFieldRef>,
    /// Selects a resource of the container: only resources limits and requests
    /// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceFieldRef")]
    pub resource_field_ref: Option<KubeadmControlPlaneKubeadmConfigSpecClusterConfigurationSchedulerExtraEnvsValueFromResourceFieldRef>,
    /// Selects a key of a secret in the pod's namespace
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretKeyRef")]
    pub secret_key_ref: Option<KubeadmControlPlaneKubeadmConfigSpecClusterConfigurationSchedulerExtraEnvsValueFromSecretKeyRef>,
}

/// Selects a key of a ConfigMap.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct KubeadmControlPlaneKubeadmConfigSpecClusterConfigurationSchedulerExtraEnvsValueFromConfigMapKeyRef {
    /// The key to select.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the ConfigMap or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
/// spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct KubeadmControlPlaneKubeadmConfigSpecClusterConfigurationSchedulerExtraEnvsValueFromFieldRef {
    /// Version of the schema the FieldPath is written in terms of, defaults to "v1".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    /// Path of the field to select in the specified API version.
    #[serde(rename = "fieldPath")]
    pub field_path: String,
}

/// Selects a resource of the container: only resources limits and requests
/// (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct KubeadmControlPlaneKubeadmConfigSpecClusterConfigurationSchedulerExtraEnvsValueFromResourceFieldRef {
    /// Container name: required for volumes, optional for env vars
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerName")]
    pub container_name: Option<String>,
    /// Specifies the output format of the exposed resources, defaults to "1"
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub divisor: Option<IntOrString>,
    /// Required: resource to select
    pub resource: String,
}

/// Selects a key of a secret in the pod's namespace
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct KubeadmControlPlaneKubeadmConfigSpecClusterConfigurationSchedulerExtraEnvsValueFromSecretKeyRef {
    /// The key of the secret to select from.  Must be a valid secret key.
    pub key: String,
    /// Name of the referent.
    /// This field is effectively required, but due to backwards compatibility is
    /// allowed to be empty. Instances of this type with an empty value here are
    /// almost certainly wrong.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Specify whether the Secret or its key must be defined
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub optional: Option<bool>,
}

/// HostPathMount contains elements describing volumes that are mounted from the
/// host.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct KubeadmControlPlaneKubeadmConfigSpecClusterConfigurationSchedulerExtraVolumes {
    /// hostPath is the path in the host that will be mounted inside
    /// the pod.
    #[serde(rename = "hostPath")]
    pub host_path: String,
    /// mountPath is the path inside the pod where hostPath will be mounted.
    #[serde(rename = "mountPath")]
    pub mount_path: String,
    /// name of the volume inside the pod template.
    pub name: String,
    /// pathType is the type of the HostPath.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pathType")]
    pub path_type: Option<String>,
    /// readOnly controls write access to the volume
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readOnly")]
    pub read_only: Option<bool>,
}

/// diskSetup specifies options for the creation of partition tables and file systems on devices.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct KubeadmControlPlaneKubeadmConfigSpecDiskSetup {
    /// filesystems specifies the list of file systems to setup.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub filesystems: Option<Vec<KubeadmControlPlaneKubeadmConfigSpecDiskSetupFilesystems>>,
    /// partitions specifies the list of the partitions to setup.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub partitions: Option<Vec<KubeadmControlPlaneKubeadmConfigSpecDiskSetupPartitions>>,
}

/// Filesystem defines the file systems to be created.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct KubeadmControlPlaneKubeadmConfigSpecDiskSetupFilesystems {
    /// device specifies the device name
    pub device: String,
    /// extraOpts defined extra options to add to the command for creating the file system.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "extraOpts")]
    pub extra_opts: Option<Vec<String>>,
    /// filesystem specifies the file system type.
    pub filesystem: String,
    /// label specifies the file system label to be used. If set to None, no label is used.
    pub label: String,
    /// overwrite defines whether or not to overwrite any existing filesystem.
    /// If true, any pre-existing file system will be destroyed. Use with Caution.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub overwrite: Option<bool>,
    /// partition specifies the partition to use. The valid options are: "auto|any", "auto", "any", "none", and <NUM>, where NUM is the actual partition number.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub partition: Option<String>,
    /// replaceFS is a special directive, used for Microsoft Azure that instructs cloud-init to replace a file system of <FS_TYPE>.
    /// NOTE: unless you define a label, this requires the use of the 'any' partition directive.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "replaceFS")]
    pub replace_fs: Option<String>,
}

/// Partition defines how to create and layout a partition.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct KubeadmControlPlaneKubeadmConfigSpecDiskSetupPartitions {
    /// device is the name of the device.
    pub device: String,
    /// layout specifies the device layout.
    /// If it is true, a single partition will be created for the entire device.
    /// When layout is false, it means don't partition or ignore existing partitioning.
    pub layout: bool,
    /// overwrite describes whether to skip checks and create the partition if a partition or filesystem is found on the device.
    /// Use with caution. Default is 'false'.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub overwrite: Option<bool>,
    /// tableType specifies the tupe of partition table. The following are supported:
    /// 'mbr': default and setups a MS-DOS partition table
    /// 'gpt': setups a GPT partition table
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tableType")]
    pub table_type: Option<KubeadmControlPlaneKubeadmConfigSpecDiskSetupPartitionsTableType>,
}

/// Partition defines how to create and layout a partition.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub enum KubeadmControlPlaneKubeadmConfigSpecDiskSetupPartitionsTableType {
    #[serde(rename = "mbr")]
    Mbr,
    #[serde(rename = "gpt")]
    Gpt,
}

/// File defines the input for generating write_files in cloud-init.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct KubeadmControlPlaneKubeadmConfigSpecFiles {
    /// append specifies whether to append Content to existing file if Path exists.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub append: Option<bool>,
    /// content is the actual content of the file.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub content: Option<String>,
    /// contentFrom is a referenced source of content to populate the file.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "contentFrom")]
    pub content_from: Option<KubeadmControlPlaneKubeadmConfigSpecFilesContentFrom>,
    /// encoding specifies the encoding of the file contents.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub encoding: Option<KubeadmControlPlaneKubeadmConfigSpecFilesEncoding>,
    /// owner specifies the ownership of the file, e.g. "root:root".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub owner: Option<String>,
    /// path specifies the full path on disk where to store the file.
    pub path: String,
    /// permissions specifies the permissions to assign to the file, e.g. "0640".
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub permissions: Option<String>,
}

/// contentFrom is a referenced source of content to populate the file.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct KubeadmControlPlaneKubeadmConfigSpecFilesContentFrom {
    /// secret represents a secret that should populate this file.
    pub secret: KubeadmControlPlaneKubeadmConfigSpecFilesContentFromSecret,
}

/// secret represents a secret that should populate this file.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct KubeadmControlPlaneKubeadmConfigSpecFilesContentFromSecret {
    /// key is the key in the secret's data map for this value.
    pub key: String,
    /// name of the secret in the KubeadmBootstrapConfig's namespace to use.
    pub name: String,
}

/// File defines the input for generating write_files in cloud-init.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub enum KubeadmControlPlaneKubeadmConfigSpecFilesEncoding {
    #[serde(rename = "base64")]
    Base64,
    #[serde(rename = "gzip")]
    Gzip,
    #[serde(rename = "gzip+base64")]
    GzipBase64,
}

/// kubeadmConfigSpec is a KubeadmConfigSpec
/// to use for initializing and joining machines to the control plane.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub enum KubeadmControlPlaneKubeadmConfigSpecFormat {
    #[serde(rename = "cloud-config")]
    CloudConfig,
    #[serde(rename = "ignition")]
    Ignition,
}

/// ignition contains Ignition specific configuration.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct KubeadmControlPlaneKubeadmConfigSpecIgnition {
    /// containerLinuxConfig contains CLC specific configuration.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "containerLinuxConfig")]
    pub container_linux_config: Option<KubeadmControlPlaneKubeadmConfigSpecIgnitionContainerLinuxConfig>,
}

/// containerLinuxConfig contains CLC specific configuration.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct KubeadmControlPlaneKubeadmConfigSpecIgnitionContainerLinuxConfig {
    /// additionalConfig contains additional configuration to be merged with the Ignition
    /// configuration generated by the bootstrapper controller. More info: https://coreos.github.io/ignition/operator-notes/#config-merging
    ///
    /// The data format is documented here: https://kinvolk.io/docs/flatcar-container-linux/latest/provisioning/cl-config/
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "additionalConfig")]
    pub additional_config: Option<String>,
    /// strict controls if AdditionalConfig should be strictly parsed. If so, warnings are treated as errors.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub strict: Option<bool>,
}

/// initConfiguration along with ClusterConfiguration are the configurations necessary for the init command
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct KubeadmControlPlaneKubeadmConfigSpecInitConfiguration {
    /// APIVersion defines the versioned schema of this representation of an object.
    /// Servers should convert recognized schemas to the latest internal value, and
    /// may reject unrecognized values.
    /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    /// bootstrapTokens is respected at `kubeadm init` time and describes a set of Bootstrap Tokens to create.
    /// This information IS NOT uploaded to the kubeadm cluster configmap, partly because of its sensitive nature
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bootstrapTokens")]
    pub bootstrap_tokens: Option<Vec<KubeadmControlPlaneKubeadmConfigSpecInitConfigurationBootstrapTokens>>,
    /// Kind is a string value representing the REST resource this object represents.
    /// Servers may infer this from the endpoint the client submits requests to.
    /// Cannot be updated.
    /// In CamelCase.
    /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kind: Option<String>,
    /// localAPIEndpoint represents the endpoint of the API server instance that's deployed on this control plane node
    /// In HA setups, this differs from ClusterConfiguration.ControlPlaneEndpoint in the sense that ControlPlaneEndpoint
    /// is the global endpoint for the cluster, which then loadbalances the requests to each individual API server. This
    /// configuration object lets you customize what IP/DNS name and port the local API server advertises it's accessible
    /// on. By default, kubeadm tries to auto-detect the IP of the default interface and use that, but in case that process
    /// fails you may set the desired value here.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localAPIEndpoint")]
    pub local_api_endpoint: Option<KubeadmControlPlaneKubeadmConfigSpecInitConfigurationLocalApiEndpoint>,
    /// nodeRegistration holds fields that relate to registering the new control-plane node to the cluster.
    /// When used in the context of control plane nodes, NodeRegistration should remain consistent
    /// across both InitConfiguration and JoinConfiguration
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeRegistration")]
    pub node_registration: Option<KubeadmControlPlaneKubeadmConfigSpecInitConfigurationNodeRegistration>,
    /// patches contains options related to applying patches to components deployed by kubeadm during
    /// "kubeadm init". The minimum kubernetes version needed to support Patches is v1.22
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub patches: Option<KubeadmControlPlaneKubeadmConfigSpecInitConfigurationPatches>,
    /// skipPhases is a list of phases to skip during command execution.
    /// The list of phases can be obtained with the "kubeadm init --help" command.
    /// This option takes effect only on Kubernetes >=1.22.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "skipPhases")]
    pub skip_phases: Option<Vec<String>>,
}

/// BootstrapToken describes one bootstrap token, stored as a Secret in the cluster.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct KubeadmControlPlaneKubeadmConfigSpecInitConfigurationBootstrapTokens {
    /// description sets a human-friendly message why this token exists and what it's used
    /// for, so other administrators can know its purpose.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// expires specifies the timestamp when this token expires. Defaults to being set
    /// dynamically at runtime based on the TTL. Expires and TTL are mutually exclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub expires: Option<String>,
    /// groups specifies the extra groups that this token will authenticate as when/if
    /// used for authentication
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub groups: Option<Vec<String>>,
    /// token is used for establishing bidirectional trust between nodes and control-planes.
    /// Used for joining nodes in the cluster.
    pub token: String,
    /// ttl defines the time to live for this token. Defaults to 24h.
    /// Expires and TTL are mutually exclusive.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ttl: Option<String>,
    /// usages describes the ways in which this token can be used. Can by default be used
    /// for establishing bidirectional trust, but that can be changed here.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub usages: Option<Vec<String>>,
}

/// localAPIEndpoint represents the endpoint of the API server instance that's deployed on this control plane node
/// In HA setups, this differs from ClusterConfiguration.ControlPlaneEndpoint in the sense that ControlPlaneEndpoint
/// is the global endpoint for the cluster, which then loadbalances the requests to each individual API server. This
/// configuration object lets you customize what IP/DNS name and port the local API server advertises it's accessible
/// on. By default, kubeadm tries to auto-detect the IP of the default interface and use that, but in case that process
/// fails you may set the desired value here.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct KubeadmControlPlaneKubeadmConfigSpecInitConfigurationLocalApiEndpoint {
    /// advertiseAddress sets the IP address for the API server to advertise.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "advertiseAddress")]
    pub advertise_address: Option<String>,
    /// bindPort sets the secure port for the API Server to bind to.
    /// Defaults to 6443.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bindPort")]
    pub bind_port: Option<i32>,
}

/// nodeRegistration holds fields that relate to registering the new control-plane node to the cluster.
/// When used in the context of control plane nodes, NodeRegistration should remain consistent
/// across both InitConfiguration and JoinConfiguration
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct KubeadmControlPlaneKubeadmConfigSpecInitConfigurationNodeRegistration {
    /// criSocket is used to retrieve container runtime info. This information will be annotated to the Node API object, for later re-use
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "criSocket")]
    pub cri_socket: Option<String>,
    /// ignorePreflightErrors provides a slice of pre-flight errors to be ignored when the current node is registered.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ignorePreflightErrors")]
    pub ignore_preflight_errors: Option<Vec<String>>,
    /// imagePullPolicy specifies the policy for image pulling
    /// during kubeadm "init" and "join" operations. The value of
    /// this field must be one of "Always", "IfNotPresent" or
    /// "Never". Defaults to "IfNotPresent". This can be used only
    /// with Kubernetes version equal to 1.22 and later.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imagePullPolicy")]
    pub image_pull_policy: Option<KubeadmControlPlaneKubeadmConfigSpecInitConfigurationNodeRegistrationImagePullPolicy>,
    /// imagePullSerial specifies if image pulling performed by kubeadm must be done serially or in parallel.
    /// This option takes effect only on Kubernetes >=1.31.0.
    /// Default: true (defaulted in kubeadm)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imagePullSerial")]
    pub image_pull_serial: Option<bool>,
    /// kubeletExtraArgs passes through extra arguments to the kubelet. The arguments here are passed to the kubelet command line via the environment file
    /// kubeadm writes at runtime for the kubelet to source. This overrides the generic base-level configuration in the kubelet-config-1.X ConfigMap
    /// Flags have higher priority when parsing. These values are local and specific to the node kubeadm is executing on.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kubeletExtraArgs")]
    pub kubelet_extra_args: Option<BTreeMap<String, String>>,
    /// name is the `.Metadata.Name` field of the Node API object that will be created in this `kubeadm init` or `kubeadm join` operation.
    /// This field is also used in the CommonName field of the kubelet's client certificate to the API server.
    /// Defaults to the hostname of the node if not provided.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// taints specifies the taints the Node API object should be registered with. If this field is unset, i.e. nil, in the `kubeadm init` process
    /// it will be defaulted to []v1.Taint{'node-role.kubernetes.io/master=""'}. If you don't want to taint your control-plane node, set this field to an
    /// empty slice, i.e. `taints: []` in the YAML file. This field is solely used for Node registration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub taints: Option<Vec<KubeadmControlPlaneKubeadmConfigSpecInitConfigurationNodeRegistrationTaints>>,
}

/// nodeRegistration holds fields that relate to registering the new control-plane node to the cluster.
/// When used in the context of control plane nodes, NodeRegistration should remain consistent
/// across both InitConfiguration and JoinConfiguration
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub enum KubeadmControlPlaneKubeadmConfigSpecInitConfigurationNodeRegistrationImagePullPolicy {
    Always,
    IfNotPresent,
    Never,
}

/// The node this Taint is attached to has the "effect" on
/// any pod that does not tolerate the Taint.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct KubeadmControlPlaneKubeadmConfigSpecInitConfigurationNodeRegistrationTaints {
    /// Required. The effect of the taint on pods
    /// that do not tolerate the taint.
    /// Valid effects are NoSchedule, PreferNoSchedule and NoExecute.
    pub effect: String,
    /// Required. The taint key to be applied to a node.
    pub key: String,
    /// TimeAdded represents the time at which the taint was added.
    /// It is only written for NoExecute taints.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeAdded")]
    pub time_added: Option<String>,
    /// The taint value corresponding to the taint key.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// patches contains options related to applying patches to components deployed by kubeadm during
/// "kubeadm init". The minimum kubernetes version needed to support Patches is v1.22
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct KubeadmControlPlaneKubeadmConfigSpecInitConfigurationPatches {
    /// directory is a path to a directory that contains files named "target[suffix][+patchtype].extension".
    /// For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "target" can be one of
    /// "kube-apiserver", "kube-controller-manager", "kube-scheduler", "etcd". "patchtype" can be one
    /// of "strategic" "merge" or "json" and they match the patch formats supported by kubectl.
    /// The default "patchtype" is "strategic". "extension" must be either "json" or "yaml".
    /// "suffix" is an optional string that can be used to determine which patches are applied
    /// first alpha-numerically.
    /// These files can be written into the target directory via KubeadmConfig.Files which
    /// specifies additional files to be created on the machine, either with content inline or
    /// by referencing a secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub directory: Option<String>,
}

/// joinConfiguration is the kubeadm configuration for the join command
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct KubeadmControlPlaneKubeadmConfigSpecJoinConfiguration {
    /// APIVersion defines the versioned schema of this representation of an object.
    /// Servers should convert recognized schemas to the latest internal value, and
    /// may reject unrecognized values.
    /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    /// caCertPath is the path to the SSL certificate authority used to
    /// secure comunications between node and control-plane.
    /// Defaults to "/etc/kubernetes/pki/ca.crt".
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caCertPath")]
    pub ca_cert_path: Option<String>,
    /// controlPlane defines the additional control plane instance to be deployed on the joining node.
    /// If nil, no additional control plane instance will be deployed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "controlPlane")]
    pub control_plane: Option<KubeadmControlPlaneKubeadmConfigSpecJoinConfigurationControlPlane>,
    /// discovery specifies the options for the kubelet to use during the TLS Bootstrap process
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub discovery: Option<KubeadmControlPlaneKubeadmConfigSpecJoinConfigurationDiscovery>,
    /// Kind is a string value representing the REST resource this object represents.
    /// Servers may infer this from the endpoint the client submits requests to.
    /// Cannot be updated.
    /// In CamelCase.
    /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kind: Option<String>,
    /// nodeRegistration holds fields that relate to registering the new control-plane node to the cluster.
    /// When used in the context of control plane nodes, NodeRegistration should remain consistent
    /// across both InitConfiguration and JoinConfiguration
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeRegistration")]
    pub node_registration: Option<KubeadmControlPlaneKubeadmConfigSpecJoinConfigurationNodeRegistration>,
    /// patches contains options related to applying patches to components deployed by kubeadm during
    /// "kubeadm join". The minimum kubernetes version needed to support Patches is v1.22
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub patches: Option<KubeadmControlPlaneKubeadmConfigSpecJoinConfigurationPatches>,
    /// skipPhases is a list of phases to skip during command execution.
    /// The list of phases can be obtained with the "kubeadm init --help" command.
    /// This option takes effect only on Kubernetes >=1.22.0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "skipPhases")]
    pub skip_phases: Option<Vec<String>>,
}

/// controlPlane defines the additional control plane instance to be deployed on the joining node.
/// If nil, no additional control plane instance will be deployed.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct KubeadmControlPlaneKubeadmConfigSpecJoinConfigurationControlPlane {
    /// localAPIEndpoint represents the endpoint of the API server instance to be deployed on this node.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "localAPIEndpoint")]
    pub local_api_endpoint: Option<KubeadmControlPlaneKubeadmConfigSpecJoinConfigurationControlPlaneLocalApiEndpoint>,
}

/// localAPIEndpoint represents the endpoint of the API server instance to be deployed on this node.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct KubeadmControlPlaneKubeadmConfigSpecJoinConfigurationControlPlaneLocalApiEndpoint {
    /// advertiseAddress sets the IP address for the API server to advertise.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "advertiseAddress")]
    pub advertise_address: Option<String>,
    /// bindPort sets the secure port for the API Server to bind to.
    /// Defaults to 6443.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bindPort")]
    pub bind_port: Option<i32>,
}

/// discovery specifies the options for the kubelet to use during the TLS Bootstrap process
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct KubeadmControlPlaneKubeadmConfigSpecJoinConfigurationDiscovery {
    /// bootstrapToken is used to set the options for bootstrap token based discovery
    /// BootstrapToken and File are mutually exclusive
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "bootstrapToken")]
    pub bootstrap_token: Option<KubeadmControlPlaneKubeadmConfigSpecJoinConfigurationDiscoveryBootstrapToken>,
    /// file is used to specify a file or URL to a kubeconfig file from which to load cluster information
    /// BootstrapToken and File are mutually exclusive
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub file: Option<KubeadmControlPlaneKubeadmConfigSpecJoinConfigurationDiscoveryFile>,
    /// timeout modifies the discovery timeout
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub timeout: Option<String>,
    /// tlsBootstrapToken is a token used for TLS bootstrapping.
    /// If .BootstrapToken is set, this field is defaulted to .BootstrapToken.Token, but can be overridden.
    /// If .File is set, this field **must be set** in case the KubeConfigFile does not contain any other authentication information
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsBootstrapToken")]
    pub tls_bootstrap_token: Option<String>,
}

/// bootstrapToken is used to set the options for bootstrap token based discovery
/// BootstrapToken and File are mutually exclusive
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct KubeadmControlPlaneKubeadmConfigSpecJoinConfigurationDiscoveryBootstrapToken {
    /// apiServerEndpoint is an IP or domain name to the API server from which info will be fetched.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiServerEndpoint")]
    pub api_server_endpoint: Option<String>,
    /// caCertHashes specifies a set of public key pins to verify
    /// when token-based discovery is used. The root CA found during discovery
    /// must match one of these values. Specifying an empty set disables root CA
    /// pinning, which can be unsafe. Each hash is specified as "<type>:<value>",
    /// where the only currently supported type is "sha256". This is a hex-encoded
    /// SHA-256 hash of the Subject Public Key Info (SPKI) object in DER-encoded
    /// ASN.1. These hashes can be calculated using, for example, OpenSSL:
    /// openssl x509 -pubkey -in ca.crt openssl rsa -pubin -outform der 2>&/dev/null | openssl dgst -sha256 -hex
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "caCertHashes")]
    pub ca_cert_hashes: Option<Vec<String>>,
    /// token is a token used to validate cluster information
    /// fetched from the control-plane.
    pub token: String,
    /// unsafeSkipCAVerification allows token-based discovery
    /// without CA verification via CACertHashes. This can weaken
    /// the security of kubeadm since other nodes can impersonate the control-plane.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "unsafeSkipCAVerification")]
    pub unsafe_skip_ca_verification: Option<bool>,
}

/// file is used to specify a file or URL to a kubeconfig file from which to load cluster information
/// BootstrapToken and File are mutually exclusive
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct KubeadmControlPlaneKubeadmConfigSpecJoinConfigurationDiscoveryFile {
    /// kubeConfig is used (optionally) to generate a KubeConfig based on the KubeadmConfig's information.
    /// The file is generated at the path specified in KubeConfigPath.
    ///
    /// Host address (server field) information is automatically populated based on the Cluster's ControlPlaneEndpoint.
    /// Certificate Authority (certificate-authority-data field) is gathered from the cluster's CA secret.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kubeConfig")]
    pub kube_config: Option<KubeadmControlPlaneKubeadmConfigSpecJoinConfigurationDiscoveryFileKubeConfig>,
    /// kubeConfigPath is used to specify the actual file path or URL to the kubeconfig file from which to load cluster information
    #[serde(rename = "kubeConfigPath")]
    pub kube_config_path: String,
}

/// kubeConfig is used (optionally) to generate a KubeConfig based on the KubeadmConfig's information.
/// The file is generated at the path specified in KubeConfigPath.
///
/// Host address (server field) information is automatically populated based on the Cluster's ControlPlaneEndpoint.
/// Certificate Authority (certificate-authority-data field) is gathered from the cluster's CA secret.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct KubeadmControlPlaneKubeadmConfigSpecJoinConfigurationDiscoveryFileKubeConfig {
    /// cluster contains information about how to communicate with the kubernetes cluster.
    ///
    /// By default the following fields are automatically populated:
    /// - Server with the Cluster's ControlPlaneEndpoint.
    /// - CertificateAuthorityData with the Cluster's CA certificate.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cluster: Option<KubeadmControlPlaneKubeadmConfigSpecJoinConfigurationDiscoveryFileKubeConfigCluster>,
    /// user contains information that describes identity information.
    /// This is used to tell the kubernetes cluster who you are.
    pub user: KubeadmControlPlaneKubeadmConfigSpecJoinConfigurationDiscoveryFileKubeConfigUser,
}

/// cluster contains information about how to communicate with the kubernetes cluster.
///
/// By default the following fields are automatically populated:
/// - Server with the Cluster's ControlPlaneEndpoint.
/// - CertificateAuthorityData with the Cluster's CA certificate.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct KubeadmControlPlaneKubeadmConfigSpecJoinConfigurationDiscoveryFileKubeConfigCluster {
    /// certificateAuthorityData contains PEM-encoded certificate authority certificates.
    ///
    /// Defaults to the Cluster's CA certificate if empty.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certificateAuthorityData")]
    pub certificate_authority_data: Option<String>,
    /// insecureSkipTLSVerify skips the validity check for the server's certificate. This will make your HTTPS connections insecure.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "insecureSkipTLSVerify")]
    pub insecure_skip_tls_verify: Option<bool>,
    /// proxyURL is the URL to the proxy to be used for all requests made by this
    /// client. URLs with "http", "https", and "socks5" schemes are supported.  If
    /// this configuration is not provided or the empty string, the client
    /// attempts to construct a proxy configuration from http_proxy and
    /// https_proxy environment variables. If these environment variables are not
    /// set, the client does not attempt to proxy requests.
    ///
    /// socks5 proxying does not currently support spdy streaming endpoints (exec,
    /// attach, port forward).
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "proxyURL")]
    pub proxy_url: Option<String>,
    /// server is the address of the kubernetes cluster (https://hostname:port).
    ///
    /// Defaults to https:// + Cluster.Spec.ControlPlaneEndpoint.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub server: Option<String>,
    /// tlsServerName is used to check server certificate. If TLSServerName is empty, the hostname used to contact the server is used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tlsServerName")]
    pub tls_server_name: Option<String>,
}

/// user contains information that describes identity information.
/// This is used to tell the kubernetes cluster who you are.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct KubeadmControlPlaneKubeadmConfigSpecJoinConfigurationDiscoveryFileKubeConfigUser {
    /// authProvider specifies a custom authentication plugin for the kubernetes cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "authProvider")]
    pub auth_provider: Option<KubeadmControlPlaneKubeadmConfigSpecJoinConfigurationDiscoveryFileKubeConfigUserAuthProvider>,
    /// exec specifies a custom exec-based authentication plugin for the kubernetes cluster.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exec: Option<KubeadmControlPlaneKubeadmConfigSpecJoinConfigurationDiscoveryFileKubeConfigUserExec>,
}

/// authProvider specifies a custom authentication plugin for the kubernetes cluster.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct KubeadmControlPlaneKubeadmConfigSpecJoinConfigurationDiscoveryFileKubeConfigUserAuthProvider {
    /// config holds the parameters for the authentication plugin.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub config: Option<BTreeMap<String, String>>,
    /// name is the name of the authentication plugin.
    pub name: String,
}

/// exec specifies a custom exec-based authentication plugin for the kubernetes cluster.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct KubeadmControlPlaneKubeadmConfigSpecJoinConfigurationDiscoveryFileKubeConfigUserExec {
    /// apiVersion is preferred input version of the ExecInfo. The returned ExecCredentials MUST use
    /// the same encoding version as the input.
    /// Defaults to client.authentication.k8s.io/v1 if not set.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    /// args is the arguments to pass to the command when executing it.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub args: Option<Vec<String>>,
    /// command to execute.
    pub command: String,
    /// env defines additional environment variables to expose to the process. These
    /// are unioned with the host's environment, as well as variables client-go uses
    /// to pass argument to the plugin.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub env: Option<Vec<KubeadmControlPlaneKubeadmConfigSpecJoinConfigurationDiscoveryFileKubeConfigUserExecEnv>>,
    /// provideClusterInfo determines whether or not to provide cluster information,
    /// which could potentially contain very large CA data, to this exec plugin as a
    /// part of the KUBERNETES_EXEC_INFO environment variable. By default, it is set
    /// to false. Package k8s.io/client-go/tools/auth/exec provides helper methods for
    /// reading this environment variable.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "provideClusterInfo")]
    pub provide_cluster_info: Option<bool>,
}

/// KubeConfigAuthExecEnv is used for setting environment variables when executing an exec-based
/// credential plugin.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct KubeadmControlPlaneKubeadmConfigSpecJoinConfigurationDiscoveryFileKubeConfigUserExecEnv {
    /// name of the environment variable
    pub name: String,
    /// value of the environment variable
    pub value: String,
}

/// nodeRegistration holds fields that relate to registering the new control-plane node to the cluster.
/// When used in the context of control plane nodes, NodeRegistration should remain consistent
/// across both InitConfiguration and JoinConfiguration
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct KubeadmControlPlaneKubeadmConfigSpecJoinConfigurationNodeRegistration {
    /// criSocket is used to retrieve container runtime info. This information will be annotated to the Node API object, for later re-use
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "criSocket")]
    pub cri_socket: Option<String>,
    /// ignorePreflightErrors provides a slice of pre-flight errors to be ignored when the current node is registered.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "ignorePreflightErrors")]
    pub ignore_preflight_errors: Option<Vec<String>>,
    /// imagePullPolicy specifies the policy for image pulling
    /// during kubeadm "init" and "join" operations. The value of
    /// this field must be one of "Always", "IfNotPresent" or
    /// "Never". Defaults to "IfNotPresent". This can be used only
    /// with Kubernetes version equal to 1.22 and later.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imagePullPolicy")]
    pub image_pull_policy: Option<KubeadmControlPlaneKubeadmConfigSpecJoinConfigurationNodeRegistrationImagePullPolicy>,
    /// imagePullSerial specifies if image pulling performed by kubeadm must be done serially or in parallel.
    /// This option takes effect only on Kubernetes >=1.31.0.
    /// Default: true (defaulted in kubeadm)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imagePullSerial")]
    pub image_pull_serial: Option<bool>,
    /// kubeletExtraArgs passes through extra arguments to the kubelet. The arguments here are passed to the kubelet command line via the environment file
    /// kubeadm writes at runtime for the kubelet to source. This overrides the generic base-level configuration in the kubelet-config-1.X ConfigMap
    /// Flags have higher priority when parsing. These values are local and specific to the node kubeadm is executing on.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "kubeletExtraArgs")]
    pub kubelet_extra_args: Option<BTreeMap<String, String>>,
    /// name is the `.Metadata.Name` field of the Node API object that will be created in this `kubeadm init` or `kubeadm join` operation.
    /// This field is also used in the CommonName field of the kubelet's client certificate to the API server.
    /// Defaults to the hostname of the node if not provided.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// taints specifies the taints the Node API object should be registered with. If this field is unset, i.e. nil, in the `kubeadm init` process
    /// it will be defaulted to []v1.Taint{'node-role.kubernetes.io/master=""'}. If you don't want to taint your control-plane node, set this field to an
    /// empty slice, i.e. `taints: []` in the YAML file. This field is solely used for Node registration.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub taints: Option<Vec<KubeadmControlPlaneKubeadmConfigSpecJoinConfigurationNodeRegistrationTaints>>,
}

/// nodeRegistration holds fields that relate to registering the new control-plane node to the cluster.
/// When used in the context of control plane nodes, NodeRegistration should remain consistent
/// across both InitConfiguration and JoinConfiguration
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub enum KubeadmControlPlaneKubeadmConfigSpecJoinConfigurationNodeRegistrationImagePullPolicy {
    Always,
    IfNotPresent,
    Never,
}

/// The node this Taint is attached to has the "effect" on
/// any pod that does not tolerate the Taint.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct KubeadmControlPlaneKubeadmConfigSpecJoinConfigurationNodeRegistrationTaints {
    /// Required. The effect of the taint on pods
    /// that do not tolerate the taint.
    /// Valid effects are NoSchedule, PreferNoSchedule and NoExecute.
    pub effect: String,
    /// Required. The taint key to be applied to a node.
    pub key: String,
    /// TimeAdded represents the time at which the taint was added.
    /// It is only written for NoExecute taints.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "timeAdded")]
    pub time_added: Option<String>,
    /// The taint value corresponding to the taint key.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// patches contains options related to applying patches to components deployed by kubeadm during
/// "kubeadm join". The minimum kubernetes version needed to support Patches is v1.22
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct KubeadmControlPlaneKubeadmConfigSpecJoinConfigurationPatches {
    /// directory is a path to a directory that contains files named "target[suffix][+patchtype].extension".
    /// For example, "kube-apiserver0+merge.yaml" or just "etcd.json". "target" can be one of
    /// "kube-apiserver", "kube-controller-manager", "kube-scheduler", "etcd". "patchtype" can be one
    /// of "strategic" "merge" or "json" and they match the patch formats supported by kubectl.
    /// The default "patchtype" is "strategic". "extension" must be either "json" or "yaml".
    /// "suffix" is an optional string that can be used to determine which patches are applied
    /// first alpha-numerically.
    /// These files can be written into the target directory via KubeadmConfig.Files which
    /// specifies additional files to be created on the machine, either with content inline or
    /// by referencing a secret.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub directory: Option<String>,
}

/// ntp specifies NTP configuration
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct KubeadmControlPlaneKubeadmConfigSpecNtp {
    /// enabled specifies whether NTP should be enabled
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    /// servers specifies which NTP servers to use
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub servers: Option<Vec<String>>,
}

/// User defines the input for a generated user in cloud-init.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct KubeadmControlPlaneKubeadmConfigSpecUsers {
    /// gecos specifies the gecos to use for the user
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub gecos: Option<String>,
    /// groups specifies the additional groups for the user
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub groups: Option<String>,
    /// homeDir specifies the home directory to use for the user
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "homeDir")]
    pub home_dir: Option<String>,
    /// inactive specifies whether to mark the user as inactive
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub inactive: Option<bool>,
    /// lockPassword specifies if password login should be disabled
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lockPassword")]
    pub lock_password: Option<bool>,
    /// name specifies the user name
    pub name: String,
    /// passwd specifies a hashed password for the user
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub passwd: Option<String>,
    /// passwdFrom is a referenced source of passwd to populate the passwd.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "passwdFrom")]
    pub passwd_from: Option<KubeadmControlPlaneKubeadmConfigSpecUsersPasswdFrom>,
    /// primaryGroup specifies the primary group for the user
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "primaryGroup")]
    pub primary_group: Option<String>,
    /// shell specifies the user's shell
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub shell: Option<String>,
    /// sshAuthorizedKeys specifies a list of ssh authorized keys for the user
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sshAuthorizedKeys")]
    pub ssh_authorized_keys: Option<Vec<String>>,
    /// sudo specifies a sudo role for the user
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sudo: Option<String>,
}

/// passwdFrom is a referenced source of passwd to populate the passwd.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct KubeadmControlPlaneKubeadmConfigSpecUsersPasswdFrom {
    /// secret represents a secret that should populate this password.
    pub secret: KubeadmControlPlaneKubeadmConfigSpecUsersPasswdFromSecret,
}

/// secret represents a secret that should populate this password.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct KubeadmControlPlaneKubeadmConfigSpecUsersPasswdFromSecret {
    /// key is the key in the secret's data map for this value.
    pub key: String,
    /// name of the secret in the KubeadmBootstrapConfig's namespace to use.
    pub name: String,
}

/// machineNamingStrategy allows changing the naming pattern used when creating Machines.
/// InfraMachines & KubeadmConfigs will use the same name as the corresponding Machines.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct KubeadmControlPlaneMachineNamingStrategy {
    /// template defines the template to use for generating the names of the Machine objects.
    /// If not defined, it will fallback to `{{ .kubeadmControlPlane.name }}-{{ .random }}`.
    /// If the generated name string exceeds 63 characters, it will be trimmed to 58 characters and will
    /// get concatenated with a random suffix of length 5.
    /// Length of the template string must not exceed 256 characters.
    /// The template allows the following variables `.cluster.name`, `.kubeadmControlPlane.name` and `.random`.
    /// The variable `.cluster.name` retrieves the name of the cluster object that owns the Machines being created.
    /// The variable `.kubeadmControlPlane.name` retrieves the name of the KubeadmControlPlane object that owns the Machines being created.
    /// The variable `.random` is substituted with random alphanumeric string, without vowels, of length 5. This variable is required
    /// part of the template. If not provided, validation will fail.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub template: Option<String>,
}

/// machineTemplate contains information about how machines
/// should be shaped when creating or updating a control plane.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct KubeadmControlPlaneMachineTemplate {
    /// infrastructureRef is a required reference to a custom resource
    /// offered by an infrastructure provider.
    #[serde(rename = "infrastructureRef")]
    pub infrastructure_ref: ObjectReference,
    /// metadata is the standard object's metadata.
    /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<KubeadmControlPlaneMachineTemplateMetadata>,
    /// nodeDeletionTimeout defines how long the machine controller will attempt to delete the Node that the Machine
    /// hosts after the Machine is marked for deletion. A duration of 0 will retry deletion indefinitely.
    /// If no value is provided, the default value for this property of the Machine resource will be used.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeDeletionTimeout")]
    pub node_deletion_timeout: Option<String>,
    /// nodeDrainTimeout is the total amount of time that the controller will spend on draining a controlplane node
    /// The default value is 0, meaning that the node can be drained without any time limitations.
    /// NOTE: NodeDrainTimeout is different from `kubectl drain --timeout`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeDrainTimeout")]
    pub node_drain_timeout: Option<String>,
    /// nodeVolumeDetachTimeout is the total amount of time that the controller will spend on waiting for all volumes
    /// to be detached. The default value is 0, meaning that the volumes can be detached without any time limitations.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeVolumeDetachTimeout")]
    pub node_volume_detach_timeout: Option<String>,
    /// readinessGates specifies additional conditions to include when evaluating Machine Ready condition;
    /// KubeadmControlPlane will always add readinessGates for the condition it is setting on the Machine:
    /// APIServerPodHealthy, SchedulerPodHealthy, ControllerManagerPodHealthy, and if etcd is managed by CKP also
    /// EtcdPodHealthy, EtcdMemberHealthy.
    ///
    /// This field can be used e.g. to instruct the machine controller to include in the computation for Machine's ready
    /// computation a condition, managed by an external controllers, reporting the status of special software/hardware installed on the Machine.
    ///
    /// NOTE: This field is considered only for computing v1beta2 conditions.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readinessGates")]
    pub readiness_gates: Option<Vec<KubeadmControlPlaneMachineTemplateReadinessGates>>,
}

/// infrastructureRef is a required reference to a custom resource
/// offered by an infrastructure provider.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct KubeadmControlPlaneMachineTemplateInfrastructureRef {
    /// API version of the referent.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    /// If referring to a piece of an object instead of an entire object, this string
    /// should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2].
    /// For example, if the object reference is to a container within a pod, this would take on a value like:
    /// "spec.containers{name}" (where "name" refers to the name of the container that triggered
    /// the event) or if no container name is specified "spec.containers[2]" (container with
    /// index 2 in this pod). This syntax is chosen only to have some well-defined way of
    /// referencing a part of an object.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldPath")]
    pub field_path: Option<String>,
    /// Kind of the referent.
    /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kind: Option<String>,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Namespace of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
    /// Specific resourceVersion to which this reference is made, if any.
    /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceVersion")]
    pub resource_version: Option<String>,
    /// UID of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uid: Option<String>,
}

/// metadata is the standard object's metadata.
/// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct KubeadmControlPlaneMachineTemplateMetadata {
    /// annotations is an unstructured key value map stored with a resource that may be
    /// set by external tools to store and retrieve arbitrary metadata. They are not
    /// queryable and should be preserved when modifying objects.
    /// More info: http://kubernetes.io/docs/user-guide/annotations
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// labels is a map of string keys and values that can be used to organize and categorize
    /// (scope and select) objects. May match selectors of replication controllers
    /// and services.
    /// More info: http://kubernetes.io/docs/user-guide/labels
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
}

/// MachineReadinessGate contains the type of a Machine condition to be used as a readiness gate.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct KubeadmControlPlaneMachineTemplateReadinessGates {
    /// conditionType refers to a condition with matching type in the Machine's condition list.
    /// If the conditions doesn't exist, it will be treated as unknown.
    /// Note: Both Cluster API conditions or conditions added by 3rd party controllers can be used as readiness gates.
    #[serde(rename = "conditionType")]
    pub condition_type: String,
    /// polarity of the conditionType specified in this readinessGate.
    /// Valid values are Positive, Negative and omitted.
    /// When omitted, the default behaviour will be Positive.
    /// A positive polarity means that the condition should report a true status under normal conditions.
    /// A negative polarity means that the condition should report a false status under normal conditions.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub polarity: Option<KubeadmControlPlaneMachineTemplateReadinessGatesPolarity>,
}

/// MachineReadinessGate contains the type of a Machine condition to be used as a readiness gate.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub enum KubeadmControlPlaneMachineTemplateReadinessGatesPolarity {
    Positive,
    Negative,
}

/// remediationStrategy is the RemediationStrategy that controls how control plane machine remediation happens.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct KubeadmControlPlaneRemediationStrategy {
    /// maxRetry is the Max number of retries while attempting to remediate an unhealthy machine.
    /// A retry happens when a machine that was created as a replacement for an unhealthy machine also fails.
    /// For example, given a control plane with three machines M1, M2, M3:
    ///
    ///
    /// A retry could happen only after RetryPeriod from the previous retry.
    /// If a machine is marked as unhealthy after MinHealthyPeriod from the previous remediation expired,
    /// this is not considered a retry anymore because the new issue is assumed unrelated from the previous one.
    ///
    /// If not set, the remedation will be retried infinitely.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxRetry")]
    pub max_retry: Option<i32>,
    /// minHealthyPeriod defines the duration after which KCP will consider any failure to a machine unrelated
    /// from the previous one. In this case the remediation is not considered a retry anymore, and thus the retry
    /// counter restarts from 0. For example, assuming MinHealthyPeriod is set to 1h (default)
    ///
    ///
    /// If not set, this value is defaulted to 1h.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minHealthyPeriod")]
    pub min_healthy_period: Option<String>,
    /// retryPeriod is the duration that KCP should wait before remediating a machine being created as a replacement
    /// for an unhealthy machine (a retry).
    ///
    /// If not set, a retry will happen immediately.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "retryPeriod")]
    pub retry_period: Option<String>,
}

/// rolloutBefore is a field to indicate a rollout should be performed
/// if the specified criteria is met.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct KubeadmControlPlaneRolloutBefore {
    /// certificatesExpiryDays indicates a rollout needs to be performed if the
    /// certificates of the machine will expire within the specified days.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certificatesExpiryDays")]
    pub certificates_expiry_days: Option<i32>,
}

/// rolloutStrategy is the RolloutStrategy to use to replace control plane machines with
/// new ones.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct KubeadmControlPlaneRolloutStrategy {
    /// rollingUpdate is the rolling update config params. Present only if
    /// RolloutStrategyType = RollingUpdate.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rollingUpdate")]
    pub rolling_update: Option<KubeadmControlPlaneRolloutStrategyRollingUpdate>,
    /// type of rollout. Currently the only supported strategy is
    /// "RollingUpdate".
    /// Default is RollingUpdate.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<KubeadmControlPlaneRolloutStrategyType>,
}

/// rollingUpdate is the rolling update config params. Present only if
/// RolloutStrategyType = RollingUpdate.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct KubeadmControlPlaneRolloutStrategyRollingUpdate {
    /// maxSurge is the maximum number of control planes that can be scheduled above or under the
    /// desired number of control planes.
    /// Value can be an absolute number 1 or 0.
    /// Defaults to 1.
    /// Example: when this is set to 1, the control plane can be scaled
    /// up immediately when the rolling update starts.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxSurge")]
    pub max_surge: Option<IntOrString>,
}

/// rolloutStrategy is the RolloutStrategy to use to replace control plane machines with
/// new ones.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub enum KubeadmControlPlaneRolloutStrategyType {
    RollingUpdate,
}

/// status is the observed state of KubeadmControlPlane.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct KubeadmControlPlaneStatus {
    /// conditions defines current service state of the KubeadmControlPlane.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
    /// failureMessage indicates that there is a terminal problem reconciling the
    /// state, and will be set to a descriptive error message.
    ///
    /// Deprecated: This field is deprecated and is going to be removed in the next apiVersion. Please see https://github.com/kubernetes-sigs/cluster-api/blob/main/docs/proposals/20240916-improve-status-in-CAPI-resources.md for more details.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failureMessage")]
    pub failure_message: Option<String>,
    /// failureReason indicates that there is a terminal problem reconciling the
    /// state, and will be set to a token value suitable for
    /// programmatic interpretation.
    ///
    /// Deprecated: This field is deprecated and is going to be removed in the next apiVersion. Please see https://github.com/kubernetes-sigs/cluster-api/blob/main/docs/proposals/20240916-improve-status-in-CAPI-resources.md for more details.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failureReason")]
    pub failure_reason: Option<String>,
    /// initialized denotes that the KubeadmControlPlane API Server is initialized and thus
    /// it can accept requests.
    /// NOTE: this field is part of the Cluster API contract and it is used to orchestrate provisioning.
    /// The value of this field is never updated after provisioning is completed. Please use conditions
    /// to check the operational state of the control plane.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub initialized: Option<bool>,
    /// lastRemediation stores info about last remediation performed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lastRemediation")]
    pub last_remediation: Option<KubeadmControlPlaneStatusLastRemediation>,
    /// observedGeneration is the latest generation observed by the controller.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    pub observed_generation: Option<i64>,
    /// ready denotes that the KubeadmControlPlane API Server became ready during initial provisioning
    /// to receive requests.
    /// NOTE: this field is part of the Cluster API contract and it is used to orchestrate provisioning.
    /// The value of this field is never updated after provisioning is completed. Please use conditions
    /// to check the operational state of the control plane.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ready: Option<bool>,
    /// readyReplicas is the total number of fully running and ready control plane machines.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readyReplicas")]
    pub ready_replicas: Option<i32>,
    /// replicas is the total number of non-terminated machines targeted by this control plane
    /// (their labels match the selector).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replicas: Option<i32>,
    /// selector is the label selector in string format to avoid introspection
    /// by clients, and is used to provide the CRD-based integration for the
    /// scale subresource and additional integrations for things like kubectl
    /// describe.. The string will be in the same format as the query-param syntax.
    /// More info about label selectors: http://kubernetes.io/docs/user-guide/labels#label-selectors
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<String>,
    /// unavailableReplicas is the total number of unavailable machines targeted by this control plane.
    /// This is the total number of machines that are still required for
    /// the deployment to have 100% available capacity. They may either
    /// be machines that are running but not yet ready or machines
    /// that still have not been created.
    ///
    /// Deprecated: This field is deprecated and is going to be removed in the next apiVersion. Please see https://github.com/kubernetes-sigs/cluster-api/blob/main/docs/proposals/20240916-improve-status-in-CAPI-resources.md for more details.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "unavailableReplicas")]
    pub unavailable_replicas: Option<i32>,
    /// updatedReplicas is the total number of non-terminated machines targeted by this control plane
    /// that have the desired template spec.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "updatedReplicas")]
    pub updated_replicas: Option<i32>,
    /// v1beta2 groups all the fields that will be added or modified in KubeadmControlPlane's status with the V1Beta2 version.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub v1beta2: Option<KubeadmControlPlaneStatusV1beta2>,
    /// version represents the minimum Kubernetes version for the control plane machines
    /// in the cluster.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}

/// lastRemediation stores info about last remediation performed.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct KubeadmControlPlaneStatusLastRemediation {
    /// machine is the machine name of the latest machine being remediated.
    pub machine: String,
    /// retryCount used to keep track of remediation retry for the last remediated machine.
    /// A retry happens when a machine that was created as a replacement for an unhealthy machine also fails.
    #[serde(rename = "retryCount")]
    pub retry_count: i32,
    /// timestamp is when last remediation happened. It is represented in RFC3339 form and is in UTC.
    pub timestamp: String,
}

/// v1beta2 groups all the fields that will be added or modified in KubeadmControlPlane's status with the V1Beta2 version.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct KubeadmControlPlaneStatusV1beta2 {
    /// availableReplicas is the number of available replicas targeted by this KubeadmControlPlane. A machine is considered available when Machine's Available condition is true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "availableReplicas")]
    pub available_replicas: Option<i32>,
    /// conditions represents the observations of a KubeadmControlPlane's current state.
    /// Known condition types are Available, CertificatesAvailable, EtcdClusterAvailable, MachinesReady, MachinesUpToDate,
    /// ScalingUp, ScalingDown, Remediating, Deleting, Paused.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
    /// readyReplicas is the number of ready replicas for this KubeadmControlPlane. A machine is considered ready when Machine's Ready condition is true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "readyReplicas")]
    pub ready_replicas: Option<i32>,
    /// upToDateReplicas is the number of up-to-date replicas targeted by this KubeadmControlPlane. A machine is considered up-to-date when Machine's UpToDate condition is true.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "upToDateReplicas")]
    pub up_to_date_replicas: Option<i32>,
}
