// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium -D Default -D PartialEq -A -d clusters.cluster.x-k8s.io
// kopium version: 0.21.1

#[allow(unused_imports)]
mod prelude {
    pub use kube::CustomResource;
    pub use schemars::JsonSchema;
    pub use serde::{Serialize, Deserialize};
    pub use std::collections::BTreeMap;
    pub use k8s_openapi::apimachinery::pkg::util::intstr::IntOrString;
    pub use k8s_openapi::apimachinery::pkg::apis::meta::v1::Condition;
    pub use k8s_openapi::api::core::v1::ObjectReference;
}
use self::prelude::*;

/// ClusterSpec defines the desired state of Cluster.
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
#[kube(group = "cluster.x-k8s.io", version = "v1beta1", kind = "Cluster", plural = "clusters")]
#[kube(namespaced)]
#[kube(status = "ClusterStatus")]
#[kube(derive="Default")]
#[kube(derive="PartialEq")]
pub struct ClusterSpec {
    /// Cluster network configuration.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "clusterNetwork")]
    pub cluster_network: Option<ClusterClusterNetwork>,
    /// ControlPlaneEndpoint represents the endpoint used to communicate with the control plane.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "controlPlaneEndpoint")]
    pub control_plane_endpoint: Option<ClusterControlPlaneEndpoint>,
    /// ControlPlaneRef is an optional reference to a provider-specific resource that holds
    /// the details for provisioning the Control Plane for a Cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "controlPlaneRef")]
    pub control_plane_ref: Option<ObjectReference>,
    /// InfrastructureRef is a reference to a provider-specific resource that holds the details
    /// for provisioning infrastructure for a cluster in said provider.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "infrastructureRef")]
    pub infrastructure_ref: Option<ObjectReference>,
    /// Paused can be used to prevent controllers from processing the Cluster and all its associated objects.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub paused: Option<bool>,
    /// This encapsulates the topology for the cluster.
    /// NOTE: It is required to enable the ClusterTopology
    /// feature gate flag to activate managed topologies support;
    /// this feature is highly experimental, and parts of it might still be not implemented.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub topology: Option<ClusterTopology>,
}

/// Cluster network configuration.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct ClusterClusterNetwork {
    /// APIServerPort specifies the port the API Server should bind to.
    /// Defaults to 6443.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiServerPort")]
    pub api_server_port: Option<i32>,
    /// The network ranges from which Pod networks are allocated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pods: Option<ClusterClusterNetworkPods>,
    /// Domain name for services.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "serviceDomain")]
    pub service_domain: Option<String>,
    /// The network ranges from which service VIPs are allocated.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub services: Option<ClusterClusterNetworkServices>,
}

/// The network ranges from which Pod networks are allocated.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct ClusterClusterNetworkPods {
    #[serde(rename = "cidrBlocks")]
    pub cidr_blocks: Vec<String>,
}

/// The network ranges from which service VIPs are allocated.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct ClusterClusterNetworkServices {
    #[serde(rename = "cidrBlocks")]
    pub cidr_blocks: Vec<String>,
}

/// ControlPlaneEndpoint represents the endpoint used to communicate with the control plane.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct ClusterControlPlaneEndpoint {
    /// The hostname on which the API server is serving.
    pub host: String,
    /// The port on which the API server is serving.
    pub port: i32,
}

/// ControlPlaneRef is an optional reference to a provider-specific resource that holds
/// the details for provisioning the Control Plane for a Cluster.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct ClusterControlPlaneRef {
    /// API version of the referent.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    /// If referring to a piece of an object instead of an entire object, this string
    /// should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2].
    /// For example, if the object reference is to a container within a pod, this would take on a value like:
    /// "spec.containers{name}" (where "name" refers to the name of the container that triggered
    /// the event) or if no container name is specified "spec.containers[2]" (container with
    /// index 2 in this pod). This syntax is chosen only to have some well-defined way of
    /// referencing a part of an object.
    /// TODO: this design is not final and this field is subject to change in the future.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldPath")]
    pub field_path: Option<String>,
    /// Kind of the referent.
    /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kind: Option<String>,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Namespace of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
    /// Specific resourceVersion to which this reference is made, if any.
    /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceVersion")]
    pub resource_version: Option<String>,
    /// UID of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uid: Option<String>,
}

/// InfrastructureRef is a reference to a provider-specific resource that holds the details
/// for provisioning infrastructure for a cluster in said provider.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct ClusterInfrastructureRef {
    /// API version of the referent.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    /// If referring to a piece of an object instead of an entire object, this string
    /// should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2].
    /// For example, if the object reference is to a container within a pod, this would take on a value like:
    /// "spec.containers{name}" (where "name" refers to the name of the container that triggered
    /// the event) or if no container name is specified "spec.containers[2]" (container with
    /// index 2 in this pod). This syntax is chosen only to have some well-defined way of
    /// referencing a part of an object.
    /// TODO: this design is not final and this field is subject to change in the future.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldPath")]
    pub field_path: Option<String>,
    /// Kind of the referent.
    /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kind: Option<String>,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Namespace of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
    /// Specific resourceVersion to which this reference is made, if any.
    /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceVersion")]
    pub resource_version: Option<String>,
    /// UID of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uid: Option<String>,
}

/// This encapsulates the topology for the cluster.
/// NOTE: It is required to enable the ClusterTopology
/// feature gate flag to activate managed topologies support;
/// this feature is highly experimental, and parts of it might still be not implemented.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct ClusterTopology {
    /// The name of the ClusterClass object to create the topology.
    pub class: String,
    /// ControlPlane describes the cluster control plane.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "controlPlane")]
    pub control_plane: Option<ClusterTopologyControlPlane>,
    /// RolloutAfter performs a rollout of the entire cluster one component at a time,
    /// control plane first and then machine deployments.
    ///
    ///
    /// Deprecated: This field has no function and is going to be removed in the next apiVersion.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rolloutAfter")]
    pub rollout_after: Option<String>,
    /// Variables can be used to customize the Cluster through
    /// patches. They must comply to the corresponding
    /// VariableClasses defined in the ClusterClass.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub variables: Option<Vec<ClusterTopologyVariables>>,
    /// The Kubernetes version of the cluster.
    pub version: String,
    /// Workers encapsulates the different constructs that form the worker nodes
    /// for the cluster.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub workers: Option<ClusterTopologyWorkers>,
}

/// ControlPlane describes the cluster control plane.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct ClusterTopologyControlPlane {
    /// MachineHealthCheck allows to enable, disable and override
    /// the MachineHealthCheck configuration in the ClusterClass for this control plane.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "machineHealthCheck")]
    pub machine_health_check: Option<ClusterTopologyControlPlaneMachineHealthCheck>,
    /// Metadata is the metadata applied to the ControlPlane and the Machines of the ControlPlane
    /// if the ControlPlaneTemplate referenced by the ClusterClass is machine based. If not, it
    /// is applied only to the ControlPlane.
    /// At runtime this metadata is merged with the corresponding metadata from the ClusterClass.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<ClusterTopologyControlPlaneMetadata>,
    /// NodeDeletionTimeout defines how long the controller will attempt to delete the Node that the Machine
    /// hosts after the Machine is marked for deletion. A duration of 0 will retry deletion indefinitely.
    /// Defaults to 10 seconds.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeDeletionTimeout")]
    pub node_deletion_timeout: Option<String>,
    /// NodeDrainTimeout is the total amount of time that the controller will spend on draining a node.
    /// The default value is 0, meaning that the node can be drained without any time limitations.
    /// NOTE: NodeDrainTimeout is different from `kubectl drain --timeout`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeDrainTimeout")]
    pub node_drain_timeout: Option<String>,
    /// NodeVolumeDetachTimeout is the total amount of time that the controller will spend on waiting for all volumes
    /// to be detached. The default value is 0, meaning that the volumes can be detached without any time limitations.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeVolumeDetachTimeout")]
    pub node_volume_detach_timeout: Option<String>,
    /// Replicas is the number of control plane nodes.
    /// If the value is nil, the ControlPlane object is created without the number of Replicas
    /// and it's assumed that the control plane controller does not implement support for this field.
    /// When specified against a control plane provider that lacks support for this field, this value will be ignored.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replicas: Option<i32>,
    /// Variables can be used to customize the ControlPlane through patches.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub variables: Option<ClusterTopologyControlPlaneVariables>,
}

/// MachineHealthCheck allows to enable, disable and override
/// the MachineHealthCheck configuration in the ClusterClass for this control plane.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct ClusterTopologyControlPlaneMachineHealthCheck {
    /// Enable controls if a MachineHealthCheck should be created for the target machines.
    ///
    ///
    /// If false: No MachineHealthCheck will be created.
    ///
    ///
    /// If not set(default): A MachineHealthCheck will be created if it is defined here or
    ///  in the associated ClusterClass. If no MachineHealthCheck is defined then none will be created.
    ///
    ///
    /// If true: A MachineHealthCheck is guaranteed to be created. Cluster validation will
    /// block if `enable` is true and no MachineHealthCheck definition is available.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enable: Option<bool>,
    /// Any further remediation is only allowed if at most "MaxUnhealthy" machines selected by
    /// "selector" are not healthy.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxUnhealthy")]
    pub max_unhealthy: Option<IntOrString>,
    /// NodeStartupTimeout allows to set the maximum time for MachineHealthCheck
    /// to consider a Machine unhealthy if a corresponding Node isn't associated
    /// through a `Spec.ProviderID` field.
    ///
    ///
    /// The duration set in this field is compared to the greatest of:
    /// - Cluster's infrastructure ready condition timestamp (if and when available)
    /// - Control Plane's initialized condition timestamp (if and when available)
    /// - Machine's infrastructure ready condition timestamp (if and when available)
    /// - Machine's metadata creation timestamp
    ///
    ///
    /// Defaults to 10 minutes.
    /// If you wish to disable this feature, set the value explicitly to 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeStartupTimeout")]
    pub node_startup_timeout: Option<String>,
    /// RemediationTemplate is a reference to a remediation template
    /// provided by an infrastructure provider.
    ///
    ///
    /// This field is completely optional, when filled, the MachineHealthCheck controller
    /// creates a new object from the template referenced and hands off remediation of the machine to
    /// a controller that lives outside of Cluster API.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "remediationTemplate")]
    pub remediation_template: Option<ObjectReference>,
    /// UnhealthyConditions contains a list of the conditions that determine
    /// whether a node is considered unhealthy. The conditions are combined in a
    /// logical OR, i.e. if any of the conditions is met, the node is unhealthy.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "unhealthyConditions")]
    pub unhealthy_conditions: Option<Vec<ClusterTopologyControlPlaneMachineHealthCheckUnhealthyConditions>>,
    /// Any further remediation is only allowed if the number of machines selected by "selector" as not healthy
    /// is within the range of "UnhealthyRange". Takes precedence over MaxUnhealthy.
    /// Eg. "[3-5]" - This means that remediation will be allowed only when:
    /// (a) there are at least 3 unhealthy machines (and)
    /// (b) there are at most 5 unhealthy machines
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "unhealthyRange")]
    pub unhealthy_range: Option<String>,
}

/// RemediationTemplate is a reference to a remediation template
/// provided by an infrastructure provider.
///
///
/// This field is completely optional, when filled, the MachineHealthCheck controller
/// creates a new object from the template referenced and hands off remediation of the machine to
/// a controller that lives outside of Cluster API.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct ClusterTopologyControlPlaneMachineHealthCheckRemediationTemplate {
    /// API version of the referent.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    /// If referring to a piece of an object instead of an entire object, this string
    /// should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2].
    /// For example, if the object reference is to a container within a pod, this would take on a value like:
    /// "spec.containers{name}" (where "name" refers to the name of the container that triggered
    /// the event) or if no container name is specified "spec.containers[2]" (container with
    /// index 2 in this pod). This syntax is chosen only to have some well-defined way of
    /// referencing a part of an object.
    /// TODO: this design is not final and this field is subject to change in the future.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldPath")]
    pub field_path: Option<String>,
    /// Kind of the referent.
    /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kind: Option<String>,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Namespace of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
    /// Specific resourceVersion to which this reference is made, if any.
    /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceVersion")]
    pub resource_version: Option<String>,
    /// UID of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uid: Option<String>,
}

/// UnhealthyCondition represents a Node condition type and value with a timeout
/// specified as a duration.  When the named condition has been in the given
/// status for at least the timeout value, a node is considered unhealthy.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct ClusterTopologyControlPlaneMachineHealthCheckUnhealthyConditions {
    pub status: String,
    pub timeout: String,
    #[serde(rename = "type")]
    pub r#type: String,
}

/// Metadata is the metadata applied to the ControlPlane and the Machines of the ControlPlane
/// if the ControlPlaneTemplate referenced by the ClusterClass is machine based. If not, it
/// is applied only to the ControlPlane.
/// At runtime this metadata is merged with the corresponding metadata from the ClusterClass.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct ClusterTopologyControlPlaneMetadata {
    /// Annotations is an unstructured key value map stored with a resource that may be
    /// set by external tools to store and retrieve arbitrary metadata. They are not
    /// queryable and should be preserved when modifying objects.
    /// More info: http://kubernetes.io/docs/user-guide/annotations
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Map of string keys and values that can be used to organize and categorize
    /// (scope and select) objects. May match selectors of replication controllers
    /// and services.
    /// More info: http://kubernetes.io/docs/user-guide/labels
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
}

/// Variables can be used to customize the ControlPlane through patches.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct ClusterTopologyControlPlaneVariables {
    /// Overrides can be used to override Cluster level variables.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub overrides: Option<Vec<ClusterTopologyControlPlaneVariablesOverrides>>,
}

/// ClusterVariable can be used to customize the Cluster through patches. Each ClusterVariable is associated with a
/// Variable definition in the ClusterClass `status` variables.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct ClusterTopologyControlPlaneVariablesOverrides {
    /// DefinitionFrom specifies where the definition of this Variable is from.
    ///
    ///
    /// Deprecated: This field is deprecated, must not be set anymore and is going to be removed in the next apiVersion.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "definitionFrom")]
    pub definition_from: Option<String>,
    /// Name of the variable.
    pub name: String,
    /// Value of the variable.
    /// Note: the value will be validated against the schema of the corresponding ClusterClassVariable
    /// from the ClusterClass.
    /// Note: We have to use apiextensionsv1.JSON instead of a custom JSON type, because controller-tools has a
    /// hard-coded schema for apiextensionsv1.JSON which cannot be produced by another type via controller-tools,
    /// i.e. it is not possible to have no type field.
    /// Ref: https://github.com/kubernetes-sigs/controller-tools/blob/d0e03a142d0ecdd5491593e941ee1d6b5d91dba6/pkg/crd/known_types.go#L106-L111
    pub value: serde_json::Value,
}

/// ClusterVariable can be used to customize the Cluster through patches. Each ClusterVariable is associated with a
/// Variable definition in the ClusterClass `status` variables.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct ClusterTopologyVariables {
    /// DefinitionFrom specifies where the definition of this Variable is from.
    ///
    ///
    /// Deprecated: This field is deprecated, must not be set anymore and is going to be removed in the next apiVersion.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "definitionFrom")]
    pub definition_from: Option<String>,
    /// Name of the variable.
    pub name: String,
    /// Value of the variable.
    /// Note: the value will be validated against the schema of the corresponding ClusterClassVariable
    /// from the ClusterClass.
    /// Note: We have to use apiextensionsv1.JSON instead of a custom JSON type, because controller-tools has a
    /// hard-coded schema for apiextensionsv1.JSON which cannot be produced by another type via controller-tools,
    /// i.e. it is not possible to have no type field.
    /// Ref: https://github.com/kubernetes-sigs/controller-tools/blob/d0e03a142d0ecdd5491593e941ee1d6b5d91dba6/pkg/crd/known_types.go#L106-L111
    pub value: serde_json::Value,
}

/// Workers encapsulates the different constructs that form the worker nodes
/// for the cluster.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct ClusterTopologyWorkers {
    /// MachineDeployments is a list of machine deployments in the cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "machineDeployments")]
    pub machine_deployments: Option<Vec<ClusterTopologyWorkersMachineDeployments>>,
    /// MachinePools is a list of machine pools in the cluster.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "machinePools")]
    pub machine_pools: Option<Vec<ClusterTopologyWorkersMachinePools>>,
}

/// MachineDeploymentTopology specifies the different parameters for a set of worker nodes in the topology.
/// This set of nodes is managed by a MachineDeployment object whose lifecycle is managed by the Cluster controller.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct ClusterTopologyWorkersMachineDeployments {
    /// Class is the name of the MachineDeploymentClass used to create the set of worker nodes.
    /// This should match one of the deployment classes defined in the ClusterClass object
    /// mentioned in the `Cluster.Spec.Class` field.
    pub class: String,
    /// FailureDomain is the failure domain the machines will be created in.
    /// Must match a key in the FailureDomains map stored on the cluster object.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failureDomain")]
    pub failure_domain: Option<String>,
    /// MachineHealthCheck allows to enable, disable and override
    /// the MachineHealthCheck configuration in the ClusterClass for this MachineDeployment.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "machineHealthCheck")]
    pub machine_health_check: Option<ClusterTopologyWorkersMachineDeploymentsMachineHealthCheck>,
    /// Metadata is the metadata applied to the MachineDeployment and the machines of the MachineDeployment.
    /// At runtime this metadata is merged with the corresponding metadata from the ClusterClass.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<ClusterTopologyWorkersMachineDeploymentsMetadata>,
    /// Minimum number of seconds for which a newly created machine should
    /// be ready.
    /// Defaults to 0 (machine will be considered available as soon as it
    /// is ready)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minReadySeconds")]
    pub min_ready_seconds: Option<i32>,
    /// Name is the unique identifier for this MachineDeploymentTopology.
    /// The value is used with other unique identifiers to create a MachineDeployment's Name
    /// (e.g. cluster's name, etc). In case the name is greater than the allowed maximum length,
    /// the values are hashed together.
    pub name: String,
    /// NodeDeletionTimeout defines how long the controller will attempt to delete the Node that the Machine
    /// hosts after the Machine is marked for deletion. A duration of 0 will retry deletion indefinitely.
    /// Defaults to 10 seconds.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeDeletionTimeout")]
    pub node_deletion_timeout: Option<String>,
    /// NodeDrainTimeout is the total amount of time that the controller will spend on draining a node.
    /// The default value is 0, meaning that the node can be drained without any time limitations.
    /// NOTE: NodeDrainTimeout is different from `kubectl drain --timeout`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeDrainTimeout")]
    pub node_drain_timeout: Option<String>,
    /// NodeVolumeDetachTimeout is the total amount of time that the controller will spend on waiting for all volumes
    /// to be detached. The default value is 0, meaning that the volumes can be detached without any time limitations.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeVolumeDetachTimeout")]
    pub node_volume_detach_timeout: Option<String>,
    /// Replicas is the number of worker nodes belonging to this set.
    /// If the value is nil, the MachineDeployment is created without the number of Replicas (defaulting to 1)
    /// and it's assumed that an external entity (like cluster autoscaler) is responsible for the management
    /// of this value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replicas: Option<i32>,
    /// The deployment strategy to use to replace existing machines with
    /// new ones.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub strategy: Option<ClusterTopologyWorkersMachineDeploymentsStrategy>,
    /// Variables can be used to customize the MachineDeployment through patches.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub variables: Option<ClusterTopologyWorkersMachineDeploymentsVariables>,
}

/// MachineHealthCheck allows to enable, disable and override
/// the MachineHealthCheck configuration in the ClusterClass for this MachineDeployment.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct ClusterTopologyWorkersMachineDeploymentsMachineHealthCheck {
    /// Enable controls if a MachineHealthCheck should be created for the target machines.
    ///
    ///
    /// If false: No MachineHealthCheck will be created.
    ///
    ///
    /// If not set(default): A MachineHealthCheck will be created if it is defined here or
    ///  in the associated ClusterClass. If no MachineHealthCheck is defined then none will be created.
    ///
    ///
    /// If true: A MachineHealthCheck is guaranteed to be created. Cluster validation will
    /// block if `enable` is true and no MachineHealthCheck definition is available.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enable: Option<bool>,
    /// Any further remediation is only allowed if at most "MaxUnhealthy" machines selected by
    /// "selector" are not healthy.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxUnhealthy")]
    pub max_unhealthy: Option<IntOrString>,
    /// NodeStartupTimeout allows to set the maximum time for MachineHealthCheck
    /// to consider a Machine unhealthy if a corresponding Node isn't associated
    /// through a `Spec.ProviderID` field.
    ///
    ///
    /// The duration set in this field is compared to the greatest of:
    /// - Cluster's infrastructure ready condition timestamp (if and when available)
    /// - Control Plane's initialized condition timestamp (if and when available)
    /// - Machine's infrastructure ready condition timestamp (if and when available)
    /// - Machine's metadata creation timestamp
    ///
    ///
    /// Defaults to 10 minutes.
    /// If you wish to disable this feature, set the value explicitly to 0.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeStartupTimeout")]
    pub node_startup_timeout: Option<String>,
    /// RemediationTemplate is a reference to a remediation template
    /// provided by an infrastructure provider.
    ///
    ///
    /// This field is completely optional, when filled, the MachineHealthCheck controller
    /// creates a new object from the template referenced and hands off remediation of the machine to
    /// a controller that lives outside of Cluster API.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "remediationTemplate")]
    pub remediation_template: Option<ObjectReference>,
    /// UnhealthyConditions contains a list of the conditions that determine
    /// whether a node is considered unhealthy. The conditions are combined in a
    /// logical OR, i.e. if any of the conditions is met, the node is unhealthy.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "unhealthyConditions")]
    pub unhealthy_conditions: Option<Vec<ClusterTopologyWorkersMachineDeploymentsMachineHealthCheckUnhealthyConditions>>,
    /// Any further remediation is only allowed if the number of machines selected by "selector" as not healthy
    /// is within the range of "UnhealthyRange". Takes precedence over MaxUnhealthy.
    /// Eg. "[3-5]" - This means that remediation will be allowed only when:
    /// (a) there are at least 3 unhealthy machines (and)
    /// (b) there are at most 5 unhealthy machines
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "unhealthyRange")]
    pub unhealthy_range: Option<String>,
}

/// RemediationTemplate is a reference to a remediation template
/// provided by an infrastructure provider.
///
///
/// This field is completely optional, when filled, the MachineHealthCheck controller
/// creates a new object from the template referenced and hands off remediation of the machine to
/// a controller that lives outside of Cluster API.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct ClusterTopologyWorkersMachineDeploymentsMachineHealthCheckRemediationTemplate {
    /// API version of the referent.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiVersion")]
    pub api_version: Option<String>,
    /// If referring to a piece of an object instead of an entire object, this string
    /// should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2].
    /// For example, if the object reference is to a container within a pod, this would take on a value like:
    /// "spec.containers{name}" (where "name" refers to the name of the container that triggered
    /// the event) or if no container name is specified "spec.containers[2]" (container with
    /// index 2 in this pod). This syntax is chosen only to have some well-defined way of
    /// referencing a part of an object.
    /// TODO: this design is not final and this field is subject to change in the future.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "fieldPath")]
    pub field_path: Option<String>,
    /// Kind of the referent.
    /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub kind: Option<String>,
    /// Name of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Namespace of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
    /// Specific resourceVersion to which this reference is made, if any.
    /// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "resourceVersion")]
    pub resource_version: Option<String>,
    /// UID of the referent.
    /// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uid: Option<String>,
}

/// UnhealthyCondition represents a Node condition type and value with a timeout
/// specified as a duration.  When the named condition has been in the given
/// status for at least the timeout value, a node is considered unhealthy.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct ClusterTopologyWorkersMachineDeploymentsMachineHealthCheckUnhealthyConditions {
    pub status: String,
    pub timeout: String,
    #[serde(rename = "type")]
    pub r#type: String,
}

/// Metadata is the metadata applied to the MachineDeployment and the machines of the MachineDeployment.
/// At runtime this metadata is merged with the corresponding metadata from the ClusterClass.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct ClusterTopologyWorkersMachineDeploymentsMetadata {
    /// Annotations is an unstructured key value map stored with a resource that may be
    /// set by external tools to store and retrieve arbitrary metadata. They are not
    /// queryable and should be preserved when modifying objects.
    /// More info: http://kubernetes.io/docs/user-guide/annotations
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Map of string keys and values that can be used to organize and categorize
    /// (scope and select) objects. May match selectors of replication controllers
    /// and services.
    /// More info: http://kubernetes.io/docs/user-guide/labels
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
}

/// The deployment strategy to use to replace existing machines with
/// new ones.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct ClusterTopologyWorkersMachineDeploymentsStrategy {
    /// Remediation controls the strategy of remediating unhealthy machines
    /// and how remediating operations should occur during the lifecycle of the dependant MachineSets.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub remediation: Option<ClusterTopologyWorkersMachineDeploymentsStrategyRemediation>,
    /// Rolling update config params. Present only if
    /// MachineDeploymentStrategyType = RollingUpdate.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rollingUpdate")]
    pub rolling_update: Option<ClusterTopologyWorkersMachineDeploymentsStrategyRollingUpdate>,
    /// Type of deployment. Allowed values are RollingUpdate and OnDelete.
    /// The default is RollingUpdate.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<ClusterTopologyWorkersMachineDeploymentsStrategyType>,
}

/// Remediation controls the strategy of remediating unhealthy machines
/// and how remediating operations should occur during the lifecycle of the dependant MachineSets.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct ClusterTopologyWorkersMachineDeploymentsStrategyRemediation {
    /// MaxInFlight determines how many in flight remediations should happen at the same time.
    ///
    ///
    /// Remediation only happens on the MachineSet with the most current revision, while
    /// older MachineSets (usually present during rollout operations) aren't allowed to remediate.
    ///
    ///
    /// Note: In general (independent of remediations), unhealthy machines are always
    /// prioritized during scale down operations over healthy ones.
    ///
    ///
    /// MaxInFlight can be set to a fixed number or a percentage.
    /// Example: when this is set to 20%, the MachineSet controller deletes at most 20% of
    /// the desired replicas.
    ///
    ///
    /// If not set, remediation is limited to all machines (bounded by replicas)
    /// under the active MachineSet's management.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxInFlight")]
    pub max_in_flight: Option<IntOrString>,
}

/// Rolling update config params. Present only if
/// MachineDeploymentStrategyType = RollingUpdate.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct ClusterTopologyWorkersMachineDeploymentsStrategyRollingUpdate {
    /// DeletePolicy defines the policy used by the MachineDeployment to identify nodes to delete when downscaling.
    /// Valid values are "Random, "Newest", "Oldest"
    /// When no value is supplied, the default DeletePolicy of MachineSet is used
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deletePolicy")]
    pub delete_policy: Option<ClusterTopologyWorkersMachineDeploymentsStrategyRollingUpdateDeletePolicy>,
    /// The maximum number of machines that can be scheduled above the
    /// desired number of machines.
    /// Value can be an absolute number (ex: 5) or a percentage of
    /// desired machines (ex: 10%).
    /// This can not be 0 if MaxUnavailable is 0.
    /// Absolute number is calculated from percentage by rounding up.
    /// Defaults to 1.
    /// Example: when this is set to 30%, the new MachineSet can be scaled
    /// up immediately when the rolling update starts, such that the total
    /// number of old and new machines do not exceed 130% of desired
    /// machines. Once old machines have been killed, new MachineSet can
    /// be scaled up further, ensuring that total number of machines running
    /// at any time during the update is at most 130% of desired machines.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxSurge")]
    pub max_surge: Option<IntOrString>,
    /// The maximum number of machines that can be unavailable during the update.
    /// Value can be an absolute number (ex: 5) or a percentage of desired
    /// machines (ex: 10%).
    /// Absolute number is calculated from percentage by rounding down.
    /// This can not be 0 if MaxSurge is 0.
    /// Defaults to 0.
    /// Example: when this is set to 30%, the old MachineSet can be scaled
    /// down to 70% of desired machines immediately when the rolling update
    /// starts. Once new machines are ready, old MachineSet can be scaled
    /// down further, followed by scaling up the new MachineSet, ensuring
    /// that the total number of machines available at all times
    /// during the update is at least 70% of desired machines.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxUnavailable")]
    pub max_unavailable: Option<IntOrString>,
}

/// Rolling update config params. Present only if
/// MachineDeploymentStrategyType = RollingUpdate.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub enum ClusterTopologyWorkersMachineDeploymentsStrategyRollingUpdateDeletePolicy {
    Random,
    Newest,
    Oldest,
}

/// The deployment strategy to use to replace existing machines with
/// new ones.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub enum ClusterTopologyWorkersMachineDeploymentsStrategyType {
    RollingUpdate,
    OnDelete,
}

/// Variables can be used to customize the MachineDeployment through patches.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct ClusterTopologyWorkersMachineDeploymentsVariables {
    /// Overrides can be used to override Cluster level variables.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub overrides: Option<Vec<ClusterTopologyWorkersMachineDeploymentsVariablesOverrides>>,
}

/// ClusterVariable can be used to customize the Cluster through patches. Each ClusterVariable is associated with a
/// Variable definition in the ClusterClass `status` variables.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct ClusterTopologyWorkersMachineDeploymentsVariablesOverrides {
    /// DefinitionFrom specifies where the definition of this Variable is from.
    ///
    ///
    /// Deprecated: This field is deprecated, must not be set anymore and is going to be removed in the next apiVersion.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "definitionFrom")]
    pub definition_from: Option<String>,
    /// Name of the variable.
    pub name: String,
    /// Value of the variable.
    /// Note: the value will be validated against the schema of the corresponding ClusterClassVariable
    /// from the ClusterClass.
    /// Note: We have to use apiextensionsv1.JSON instead of a custom JSON type, because controller-tools has a
    /// hard-coded schema for apiextensionsv1.JSON which cannot be produced by another type via controller-tools,
    /// i.e. it is not possible to have no type field.
    /// Ref: https://github.com/kubernetes-sigs/controller-tools/blob/d0e03a142d0ecdd5491593e941ee1d6b5d91dba6/pkg/crd/known_types.go#L106-L111
    pub value: serde_json::Value,
}

/// MachinePoolTopology specifies the different parameters for a pool of worker nodes in the topology.
/// This pool of nodes is managed by a MachinePool object whose lifecycle is managed by the Cluster controller.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct ClusterTopologyWorkersMachinePools {
    /// Class is the name of the MachinePoolClass used to create the pool of worker nodes.
    /// This should match one of the deployment classes defined in the ClusterClass object
    /// mentioned in the `Cluster.Spec.Class` field.
    pub class: String,
    /// FailureDomains is the list of failure domains the machine pool will be created in.
    /// Must match a key in the FailureDomains map stored on the cluster object.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failureDomains")]
    pub failure_domains: Option<Vec<String>>,
    /// Metadata is the metadata applied to the MachinePool.
    /// At runtime this metadata is merged with the corresponding metadata from the ClusterClass.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub metadata: Option<ClusterTopologyWorkersMachinePoolsMetadata>,
    /// Minimum number of seconds for which a newly created machine pool should
    /// be ready.
    /// Defaults to 0 (machine will be considered available as soon as it
    /// is ready)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "minReadySeconds")]
    pub min_ready_seconds: Option<i32>,
    /// Name is the unique identifier for this MachinePoolTopology.
    /// The value is used with other unique identifiers to create a MachinePool's Name
    /// (e.g. cluster's name, etc). In case the name is greater than the allowed maximum length,
    /// the values are hashed together.
    pub name: String,
    /// NodeDeletionTimeout defines how long the controller will attempt to delete the Node that the MachinePool
    /// hosts after the MachinePool is marked for deletion. A duration of 0 will retry deletion indefinitely.
    /// Defaults to 10 seconds.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeDeletionTimeout")]
    pub node_deletion_timeout: Option<String>,
    /// NodeDrainTimeout is the total amount of time that the controller will spend on draining a node.
    /// The default value is 0, meaning that the node can be drained without any time limitations.
    /// NOTE: NodeDrainTimeout is different from `kubectl drain --timeout`
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeDrainTimeout")]
    pub node_drain_timeout: Option<String>,
    /// NodeVolumeDetachTimeout is the total amount of time that the controller will spend on waiting for all volumes
    /// to be detached. The default value is 0, meaning that the volumes can be detached without any time limitations.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "nodeVolumeDetachTimeout")]
    pub node_volume_detach_timeout: Option<String>,
    /// Replicas is the number of nodes belonging to this pool.
    /// If the value is nil, the MachinePool is created without the number of Replicas (defaulting to 1)
    /// and it's assumed that an external entity (like cluster autoscaler) is responsible for the management
    /// of this value.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub replicas: Option<i32>,
    /// Variables can be used to customize the MachinePool through patches.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub variables: Option<ClusterTopologyWorkersMachinePoolsVariables>,
}

/// Metadata is the metadata applied to the MachinePool.
/// At runtime this metadata is merged with the corresponding metadata from the ClusterClass.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct ClusterTopologyWorkersMachinePoolsMetadata {
    /// Annotations is an unstructured key value map stored with a resource that may be
    /// set by external tools to store and retrieve arbitrary metadata. They are not
    /// queryable and should be preserved when modifying objects.
    /// More info: http://kubernetes.io/docs/user-guide/annotations
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub annotations: Option<BTreeMap<String, String>>,
    /// Map of string keys and values that can be used to organize and categorize
    /// (scope and select) objects. May match selectors of replication controllers
    /// and services.
    /// More info: http://kubernetes.io/docs/user-guide/labels
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<BTreeMap<String, String>>,
}

/// Variables can be used to customize the MachinePool through patches.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct ClusterTopologyWorkersMachinePoolsVariables {
    /// Overrides can be used to override Cluster level variables.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub overrides: Option<Vec<ClusterTopologyWorkersMachinePoolsVariablesOverrides>>,
}

/// ClusterVariable can be used to customize the Cluster through patches. Each ClusterVariable is associated with a
/// Variable definition in the ClusterClass `status` variables.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct ClusterTopologyWorkersMachinePoolsVariablesOverrides {
    /// DefinitionFrom specifies where the definition of this Variable is from.
    ///
    ///
    /// Deprecated: This field is deprecated, must not be set anymore and is going to be removed in the next apiVersion.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "definitionFrom")]
    pub definition_from: Option<String>,
    /// Name of the variable.
    pub name: String,
    /// Value of the variable.
    /// Note: the value will be validated against the schema of the corresponding ClusterClassVariable
    /// from the ClusterClass.
    /// Note: We have to use apiextensionsv1.JSON instead of a custom JSON type, because controller-tools has a
    /// hard-coded schema for apiextensionsv1.JSON which cannot be produced by another type via controller-tools,
    /// i.e. it is not possible to have no type field.
    /// Ref: https://github.com/kubernetes-sigs/controller-tools/blob/d0e03a142d0ecdd5491593e941ee1d6b5d91dba6/pkg/crd/known_types.go#L106-L111
    pub value: serde_json::Value,
}

/// ClusterStatus defines the observed state of Cluster.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct ClusterStatus {
    /// Conditions defines current service state of the cluster.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<Condition>>,
    /// ControlPlaneReady denotes if the control plane became ready during initial provisioning
    /// to receive requests.
    /// NOTE: this field is part of the Cluster API contract and it is used to orchestrate provisioning.
    /// The value of this field is never updated after provisioning is completed. Please use conditions
    /// to check the operational state of the control plane.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "controlPlaneReady")]
    pub control_plane_ready: Option<bool>,
    /// FailureDomains is a slice of failure domain objects synced from the infrastructure provider.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failureDomains")]
    pub failure_domains: Option<BTreeMap<String, ClusterStatusFailureDomains>>,
    /// FailureMessage indicates that there is a fatal problem reconciling the
    /// state, and will be set to a descriptive error message.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failureMessage")]
    pub failure_message: Option<String>,
    /// FailureReason indicates that there is a fatal problem reconciling the
    /// state, and will be set to a token value suitable for
    /// programmatic interpretation.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "failureReason")]
    pub failure_reason: Option<String>,
    /// InfrastructureReady is the state of the infrastructure provider.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "infrastructureReady")]
    pub infrastructure_ready: Option<bool>,
    /// ObservedGeneration is the latest generation observed by the controller.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    pub observed_generation: Option<i64>,
    /// Phase represents the current phase of cluster actuation.
    /// E.g. Pending, Running, Terminating, Failed etc.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub phase: Option<String>,
}

/// FailureDomains is a slice of failure domain objects synced from the infrastructure provider.
#[derive(Serialize, Deserialize, Clone, Debug, Default, PartialEq, JsonSchema)]
pub struct ClusterStatusFailureDomains {
    /// Attributes is a free form map of attributes an infrastructure provider might use or require.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub attributes: Option<BTreeMap<String, String>>,
    /// ControlPlane determines if this failure domain is suitable for use by control plane machines.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "controlPlane")]
    pub control_plane: Option<bool>,
}
